<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>Overgrowth â€” Web Prototype (Smarter AI)</title>
<style>
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:#0f172a;color:#e2e8f0}
#app{max-width:1100px;margin:0 auto;padding:12px}
header{display:flex;align-items:center;justify-content:space-between}
h1{margin:8px 0}
.pill{padding:4px 10px;border-radius:999px;background:#1e293b;opacity:.9;font-size:.9rem}
main{margin-top:8px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
button{border:0;padding:10px 14px;border-radius:10px;background:#22c55e;color:#062;cursor:pointer;font-weight:700}
button[disabled]{opacity:.6;cursor:not-allowed;filter:grayscale(.3)}
.card{width:160px;background:#111827;border:2px solid #334155;border-radius:12px;padding:8px;position:relative}
.card .name{font-weight:700}
.card .meta{font-size:.8rem;opacity:.8}
.card .stats{display:flex;justify-content:space-between;margin-top:4px}
.card .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
.tag{padding:2px 6px;border-radius:6px;background:#1f2937;font-size:.75rem}
.card-row,.bench-row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
.garden-wrap{margin-top:10px;padding:8px;border:1px dashed #334155;border-radius:10px}
.hidden{display:none}
.hands .hand{flex:1;min-width:280px}
.board{display:flex;gap:12px;margin:8px 0}
.column{flex:1}
.slot{min-height:180px;border:2px dashed #334155;border-radius:12px;padding:6px;display:flex;align-items:center;justify-content:center}
.boards{display:grid;grid-template-columns:1fr;gap:12px}
.active-row .slot{min-height:190px}
#action-panel{margin-top:12px;padding:10px;border:1px solid #334155;border-radius:12px;background:#0b1220}
#log{margin-top:10px;max-height:220px;overflow:auto;font-family:ui-monospace,monospace;background:#0a0f1b;padding:8px;border-radius:8px;font-size:.9rem}
#turn-banner{padding:8px;border-radius:8px;background:#1f2937;margin-bottom:8px}
footer{margin-top:16px;opacity:.7}
.card.selectable{outline:2px solid #22c55e}
.card.ai{border-color:#64748b}
.slot.highlight{background:#0b1329}
#status-line{margin:6px 0;opacity:.9}
@media (min-width:900px){.boards{grid-template-columns:1fr 1fr}}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>ðŸŒ¿ Overgrowth</h1>
    <div class="pill">v1.2 â€” smarter AI merged (single file)</div>
  </header>

  <main>
    <section id="setup">
      <h2>Gardening Phase</h2>
      <div class="row">
        <button id="btn-new">New Game</button>
        <button id="btn-help">Help / Rules</button>
      </div>
      <div id="help" class="hidden">
        <p>Draft from the Garden of 6 face-up cards. You and the AI draft until both have 6 cards.
          The AI **draws all of its cards from the Garden** and completes its drafting automatically.</p>
        <details>
          <summary>Implemented rules</summary>
          <ul>
            <li>Types loop (Nocturnal &gt; Fungal &gt; Normal &gt; Thorn &gt; Water &gt; Sun &gt; Nocturnal), +10 on direct attacks.</li>
            <li>Energy/exhaustion: Attack costs 1 EN; actives cost listed EN; at 0 EN you are exhausted next turn, then refill.</li>
            <li>Formations: Primary, Secondary, Support; Bench x3. Bench enters with full energy; bench energy not tracked.</li>
            <li>Statuses: Stunned, Rooted, Weakened, Burned, Poisoned X, Cover, Anchor.</li>
            <li>Swap penalties: 1 swap â†’ frontline attacks at half dmg; 2 swaps â†’ no frontline attacks that turn.</li>
            <li>Victory: defeat all enemy plants.</li>
          </ul>
        </details>
      </div>

      <div class="garden-wrap">
        <h3>Garden (6 face-up)</h3>
        <div id="garden" class="card-row"></div>
        <div class="row">
          <button id="btn-flip" disabled>Flip / Refill Garden</button>
        </div>
      </div>

      <div class="row hands">
        <div class="hand">
          <h3>Your Drafted Cards (<span id="phc">0</span>/6)</h3>
          <div id="pHand" class="card-row"></div>
        </div>
        <div class="hand">
          <h3>AI Drafted (hidden)</h3>
          <div id="aHand" class="card-row hidden"></div>
        </div>
      </div>
      <div class="row">
        <button id="btn-arrange" disabled>Finish Drafting & Arrange</button>
      </div>
    </section>

    <section id="formation" class="hidden">
      <h2>Arrange Formation</h2>
      <p>Tap a card in your hand then tap a slot. Fill Primary, Secondary, and Support; the rest go to Bench.</p>
      <div class="board">
        <div class="column"><h4>Support</h4><div class="slot" data-slot="player-support"></div></div>
        <div class="column"><h4>Primary</h4><div class="slot" data-slot="player-primary"></div></div>
        <div class="column"><h4>Secondary</h4><div class="slot" data-slot="player-secondary"></div></div>
      </div>
      <h4>Bench (auto from remaining)</h4>
      <div id="player-bench-setup" class="bench-row"></div>
      <div class="row"><button id="btn-begin" disabled>Begin Combat</button></div>
    </section>

    <section id="combat" class="hidden">
      <h2>Combat Phase</h2>
      <div id="turn-banner"></div>
      <div class="boards">
        <div class="side">
          <h3>AI</h3>
          <div class="row active-row">
            <div class="slot" data-slot="ai-support"></div>
            <div class="slot" data-slot="ai-primary"></div>
            <div class="slot" data-slot="ai-secondary"></div>
          </div>
          <div id="ai-bench" class="bench-row"></div>
        </div>
        <div class="side">
          <h3>You</h3>
          <div class="row active-row">
            <div class="slot" data-slot="player-support"></div>
            <div class="slot" data-slot="player-primary"></div>
            <div class="slot" data-slot="player-secondary"></div>
          </div>
          <div id="player-bench" class="bench-row"></div>
        </div>
      </div>

      <div id="action-panel">
        <h3>Your Actions</h3>
        <div id="status-line"></div>
        <div class="row">
          <button id="btn-ap" disabled>Attack (Primary)</button>
          <button id="btn-as" disabled>Attack (Secondary)</button>
        </div>
        <div class="row">
          <button id="btn-pp" disabled>Use Active (Primary)</button>
          <button id="btn-ps" disabled>Use Active (Secondary)</button>
          <button id="btn-pu" disabled>Use Active (Support)</button>
        </div>
        <div class="row">
          <button id="btn-swap" disabled>Swap / Reorder</button>
          <button id="btn-end" disabled>End Turn</button>
        </div>
        <div id="log"></div>
      </div>
    </section>
  </main>

  <footer>Â© Overgrowth prototype â€” single HTML file for GitHub Pages</footer>
</div>

<script>
/* =========================
   Overgrowth â€” Single-file Web Prototype (v1.2)
   - Smarter AI integrated into the original single file.
   ========================= */

const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

/* -------- Card DB -------- */
const TYPES = ["Sun","Water","Thorn","Fungal","Normal","Nocturnal"];
const ADV = { Nocturnal:"Fungal", Fungal:"Normal", Normal:"Thorn", Thorn:"Water", Water:"Sun", Sun:"Nocturnal" };

const BASE = [
  {name:"Solar Sprout", type:"Sun", rarity:"Common", energy:2, hp:30, atk:10, passive:{kind:"burnShield",text:"-10 from next hit if fresh"}, active:{cost:2,kind:"energize",value:1,target:"ally",text:"Energize ally +1"}},
  {name:"Helio Bloom", type:"Sun", rarity:"Uncommon", energy:3, hp:35, atk:12, passive:{kind:"atkAura",value:2,text:"+2 ATK to adjacent"}, active:{cost:2,kind:"burn",value:1,target:"enemy",text:"Burn: +10 taken next hit"}},
  {name:"Dawn Cactus", type:"Sun", rarity:"Rare", energy:3, hp:40, atk:12, passive:{kind:"anchor",text:"Anchor"}, active:{cost:3,kind:"heal",value:10,target:"ally",text:"Heal 10"}},

  {name:"Brook Lily", type:"Water", rarity:"Common", energy:2, hp:28, atk:10, passive:{kind:"burnImmune",text:"Immune to Burn"}, active:{cost:2,kind:"heal",value:8,target:"ally",text:"Heal 8"}},
  {name:"Tide Fern", type:"Water", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"vitalize",value:1,text:"End: ally +1 EN"}, active:{cost:2,kind:"stun",value:1,target:"enemy",text:"Stun 1"}},
  {name:"Abyss Lotus", type:"Water", rarity:"Rare", energy:3, hp:36, atk:12, passive:{kind:"regen",value:3,text:"End: regen 3"}, active:{cost:3,kind:"poison",value:2,target:"enemy",text:"Poison 2"}},

  {name:"Bramble Guard", type:"Thorn", rarity:"Common", energy:2, hp:40, atk:10, passive:{kind:"thorns",value:5,text:"Reflect 5 on hit"}, active:{cost:2,kind:"cover",value:5,target:"ally",text:"Cover -5"}},
  {name:"Spine Oak", type:"Thorn", rarity:"Uncommon", energy:3, hp:45, atk:12, passive:{kind:"fortify",value:5,text:"Shield 5 at start"}, active:{cost:3,kind:"root",value:1,target:"enemy",text:"Root 1"}},
  {name:"Citadel Briar", type:"Thorn", rarity:"Rare", energy:3, hp:50, atk:12, passive:{kind:"anchor",text:"Anchor"}, active:{cost:2,kind:"energize",value:2,target:"ally",text:"Energize +2"}},

  {name:"Myco Puff", type:"Fungal", rarity:"Common", energy:2, hp:30, atk:10, passive:{kind:"spores",value:2,text:"20% weaken on hit"}, active:{cost:2,kind:"poison",value:1,target:"enemy",text:"Poison 1"}},
  {name:"Glow Cap", type:"Fungal", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"nightAlly",value:2,text:"+2 ATK if Nocturnal ally"}, active:{cost:2,kind:"seed",value:1,target:"self",text:"Seed 1"}},
  {name:"Rot Lord", type:"Fungal", rarity:"Rare", energy:3, hp:38, atk:12, passive:{kind:"decay",value:2,text:"+2 damage taken by enemies"}, active:{cost:3,kind:"drain",value:1,target:"enemy",text:"Drain 1 EN (Primary)"}},

  {name:"Meadow Bud", type:"Normal", rarity:"Common", energy:2, hp:30, atk:12, passive:{kind:"balanced",text:"â€”"}, active:{cost:2,kind:"heal",value:6,target:"ally",text:"Heal 6"}},
  {name:"Field Rowan", type:"Normal", rarity:"Uncommon", energy:3, hp:34, atk:12, passive:{kind:"chain",text:"Chain display"}, active:{cost:2,kind:"energize",value:1,target:"ally",text:"Energize +1"}},
  {name:"Highland Birch", type:"Normal", rarity:"Rare", energy:3, hp:36, atk:14, passive:{kind:"steadfast",value:2,text:"-2 dmg from attacks"}, active:{cost:3,kind:"weaken",value:1,target:"enemy",text:"Weaken -5 next"}},

  {name:"Night Shade", type:"Nocturnal", rarity:"Common", energy:2, hp:28, atk:12, passive:{kind:"evasive",value:10,text:"10% dodge"}, active:{cost:2,kind:"stun",value:1,target:"enemy",text:"Stun 1"}},
  {name:"Moon Orchid", type:"Nocturnal", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"shadowAtk",value:2,text:"+2 first strike"}, active:{cost:2,kind:"energize",value:2,target:"self",text:"Self +2 EN"}},
  {name:"Eclipse Ivy", type:"Nocturnal", rarity:"Rare", energy:3, hp:34, atk:14, passive:{kind:"ambush",value:4,text:"+4 first attack"}, active:{cost:3,kind:"seed",value:1,target:"self",text:"Seed 1"}}
];

// expand to ~60+ cards with slight variants
let ALL = []; let idc=1;
for (const b of BASE){
  const add = (o)=>ALL.push({...o,id:idc++});
  add(b);
  const copies = b.rarity==="Common"?3 : b.rarity==="Uncommon"?2 : 1;
  for(let i=0;i<copies;i++){
    const v = {...b};
    v.name = b.name+" +"+(i+1);
    v.hp = b.hp + (i%2===0?2:0);
    v.atk = b.atk + (i%2?1:0);
    add(v);
  }
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a;}
const clone = o => JSON.parse(JSON.stringify(o));

/* -------- Game State -------- */
const G = {
  phase:"draft",
  deck:[],
  garden:[],
  player:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
  ai:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
  current:"player",
  log:[]
};

function log(msg){ G.log.push(msg); renderLog(); }
function label(side){ return side==="player"?"You":"AI"; }

/* -------- UI bootstrap -------- */
$("#btn-help").onclick = ()=> $("#help").classList.toggle("hidden");
$("#btn-new").onclick = newGame;
$("#btn-flip").onclick = flipOrRefill;
$("#btn-arrange").onclick = endDraftToArrange;
$("#btn-begin").onclick = beginCombat;

$("#btn-ap").onclick = ()=> doAttack("player","primary");
$("#btn-as").onclick = ()=> doAttack("player","secondary");
$("#btn-pp").onclick = ()=> useActive("player","primary");
$("#btn-ps").onclick = ()=> useActive("player","secondary");
$("#btn-pu").onclick = ()=> useActive("player","support");
$("#btn-swap").onclick = ()=> startSwapFlow();
$("#btn-end").onclick = ()=> endTurn();

/* -------- New Game / Drafting -------- */
function newGame(){
  Object.assign(G,{
    phase:"draft",
    deck:shuffle(ALL.map(clone)),
    garden:[],
    player:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
    ai:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
    current:"player",
    log:[]
  });
  $("#setup").classList.remove("hidden");
  $("#formation").classList.add("hidden");
  $("#combat").classList.add("hidden");
  $("#btn-flip").disabled = false;
  $("#btn-arrange").disabled = true;
  $("#phc").textContent = "0";
  renderGarden();
  renderHands();
  log("ðŸŒ± New game. Flip to reveal the Garden.");
}

function flipOrRefill(){
  while(G.garden.length<6 && G.deck.length>0){ G.garden.push(G.deck.pop()); }
  $("#btn-flip").disabled = true;
  log("ðŸŒ¼ Garden ready. Draft until both have 6. AI drafts automatically.");
  renderGarden();
}

// Player picks from Garden
function pickFromGarden(idx){
  if(G.phase!=="draft") return;
  const c = G.garden.splice(idx,1)[0];
  if(!c) return;
  G.player.hand.push(c);
  log(`You drafted ${c.name}.`);
  refillGardenForDraft();
  aiDraftUntilBalanced();
  updateDraftButtons();
  renderAll();
}

function refillGardenForDraft(){
  while(G.garden.length<6 && G.deck.length>0 && (G.player.hand.length<6 || G.ai.hand.length<6)){
    G.garden.push(G.deck.pop());
  }
}

function aiDraftUntilBalanced(){
  while(G.ai.hand.length < Math.min(G.player.hand.length,6)){
    aiPickOnce();
    refillGardenForDraft();
  }
  while(G.player.hand.length>=6 && G.ai.hand.length<6){
    aiPickOnce();
    refillGardenForDraft();
  }
}

// --- SMARTER AI DRAFT: counters player's revealed types, prefers stats/rarity/coverage
function aiPickOnce(){
  if(G.garden.length===0) return;
  const playerTypes = G.player.hand.map(c=>c.type);
  const counts = {};
  for(const h of G.ai.hand){ counts[h.type]=(counts[h.type]||0)+1; }

  const ranked = G.garden.map((c,i)=>{
    let s = 0;
    // base stats and rarity
    s += (c.hp/6) + (c.atk/4) + c.energy;
    if(c.rarity==="Rare") s+=3; else if(c.rarity==="Uncommon") s+=1;
    // type coverage bonus (prefer new types)
    s += (counts[c.type]||0)===0 ? 2 : 0;
    // counter bonus: if this card's type has advantage over any revealed player type
    const counters = playerTypes.some(pt => ADV[c.type]===pt);
    if(counters) s += 3.5;
    // synergy: healers/energizers get a small boost
    if(c.active && (c.active.kind==="heal"||c.active.kind==="energize")) s+=1.2;
    return {c,i,score:s};
  }).sort((a,b)=>b.score-a.score);

  const pick = ranked[0];
  const card = G.garden.splice(pick.i,1)[0];
  G.ai.hand.push(card);
  log(`ðŸ¤– AI drafted ${card.name}.`);
}

function updateDraftButtons(){
  $("#phc").textContent = G.player.hand.length+"/6";
  $("#btn-arrange").disabled = !(G.player.hand.length>=6 && G.ai.hand.length>=6);
}

function endDraftToArrange(){
  G.phase="arrange";
  $("#setup").classList.add("hidden");
  $("#formation").classList.remove("hidden");
  renderArrange();
  aiArrange();
}

let selectedFromHand = null;
function renderArrange(){
  const hand = $("#pHand"); hand.innerHTML="";
  G.player.hand.forEach((c,i)=>{
    const el = renderCard(c);
    el.classList.add("selectable");
    el.onclick = ()=>{ selectedFromHand = {i}; highlightSlots(true); };
    hand.appendChild(el);
  });

  $$(".slot[data-slot^='player-']").forEach(s=>{
    s.innerHTML = "(empty)";
    s.onclick = ()=>{
      if(!selectedFromHand) return;
      const role = s.dataset.slot.split("-")[1];
      placeIntoRole(role, G.player.hand.splice(selectedFromHand.i,1)[0], "player");
      selectedFromHand = null; highlightSlots(false); renderArrange();
    };
  });

  const benchHold = $("#player-bench-setup"); benchHold.innerHTML="";
  G.player.hand.forEach(c=> benchHold.appendChild(renderMini(c)));

  const ready = G.player.formation.primary && G.player.formation.secondary && G.player.formation.support;
  $("#btn-begin").disabled = !ready || (G.player.hand.length!==3);
}

function highlightSlots(on){
  $$(".slot[data-slot^='player-']").forEach(s => s.classList.toggle("highlight", !!on));
}

function placeIntoRole(role, card, side){
  const u = initUnit(card);
  const F = side==="player" ? G.player.formation : G.ai.formation;
  F[role] = u;
}

// --- AI arrangement (unchanged core, but solid baseline)
function aiArrange(){
  const picks = G.ai.hand.slice();
  picks.sort((a,b)=>b.hp-a.hp); const P = initUnit(picks.shift());
  picks.sort((a,b)=>b.atk-a.atk); const S = initUnit(picks.shift());
  let idx = picks.findIndex(x=> x.active && (x.active.kind==="heal"||x.active.kind==="energize"));
  if(idx<0) idx=0;
  const U = initUnit(picks.splice(idx,1)[0]);
  G.ai.formation = {primary:P, secondary:S, support:U, bench:picks.map(initUnit)};
}

function beginCombat(){
  const bench = G.player.hand.splice(0).map(initUnit);
  G.player.formation.bench = bench;

  $("#formation").classList.add("hidden");
  $("#combat").classList.remove("hidden");
  G.phase="combat";
  G.current="player";
  G.player.acted = {primary:false,secondary:false,support:false};
  G.ai.acted = {primary:false,secondary:false,support:false};
  G.player.swaps=0; G.ai.swaps=0;
  log("âš”ï¸ Combat begins! Your turn.");
  updateTurnBanner();
  renderCombatBoards();
  enableActionButtons();
}

/* -------- Units / Status -------- */
function initUnit(card){
  if(!card) return null;
  return {
    ...clone(card),
    curHP: card.hp, curEN: card.energy,
    exhausted:false,
    status:{stunned:0,rooted:0,weakened:0,burned:0,poisoned:0,cover:0,anchor:(card.passive&&card.passive.kind==="anchor")?1:0},
    firstBonus:(card.passive&&card.passive.kind==="ambush")?(card.passive.value||0):0,
    shield:(card.passive&&card.passive.kind==="fortify")?(card.passive.value||0):0
  };
}

function unitAlive(u){ return u && u.curHP>0; }
function unitCanAct(u){ return unitAlive(u) && !u.exhausted && u.status.stunned<=0; }

/* -------- Rendering -------- */
function renderGarden(){
  const g = $("#garden"); g.innerHTML="";
  G.garden.forEach((c,i)=>{
    const el = renderCard(c);
    if(G.phase==="draft") { el.classList.add("selectable"); el.onclick = ()=> pickFromGarden(i); }
    g.appendChild(el);
  });
}

function renderHands(){
  const ph = $("#pHand"); if(ph){ ph.innerHTML=""; G.player.hand.forEach(c=> ph.appendChild(renderCard(c))); }
  const ah = $("#aHand"); if(ah){ ah.innerHTML=""; G.ai.hand.forEach(c=> { const el=renderCard(c); el.classList.add("ai"); ah.appendChild(el);}); }
}

function renderCard(c){
  const el = document.createElement("div"); el.className="card";
  el.innerHTML = `
    <div class="name">${c.name}</div>
    <div class="meta">${c.type} â€¢ ${c.rarity}</div>
    <div class="stats"><span>HP: ${c.hp}</span><span>ATK: ${c.atk}</span></div>
    <div class="stats"><span>EN: ${c.energy}</span></div>
    <div class="tags"><span class="tag">Passive: ${c.passive?c.passive.text:"â€”"}</span></div>
    <div class="tags"><span class="tag">Active: ${c.active? c.active.text+" (cost "+c.active.cost+")":"â€”"}</span></div>`;
  return el;
}
function renderMini(c){
  const el = document.createElement("div"); el.className="card";
  el.innerHTML = `<div class="name">${c.name}</div><div class="meta">${c.type}</div>`;
  return el;
}

function renderCombatBoards(){
  const PF = G.player.formation, AF = G.ai.formation;

  function fill(selector, u){
    const s = document.querySelector(`.slot[data-slot="${selector}"]`);
    s.innerHTML = "";
    if(!u){ s.textContent="(empty)"; return; }
    const el = document.createElement("div"); el.className="card";
    el.innerHTML = `
      <div class="name">${u.name}</div>
      <div class="meta">${u.type} â€¢ ${u.rarity}</div>
      <div class="stats"><span>HP: ${u.curHP}</span><span>ATK: ${u.atk}</span></div>
      <div class="stats"><span>EN: ${u.curEN}${u.exhausted?" (exhausted)":" "}</span></div>
      <div class="tags">
        ${u.status.stunned>0?'<span class="tag">Stunned</span>':""}
        ${u.status.rooted>0?'<span class="tag">Rooted</span>':""}
        ${u.status.weakened>0?'<span class="tag">Weakened</span>':""}
        ${u.status.burned>0?'<span class="tag">Burned</span>':""}
        ${u.status.poisoned>0?'<span class="tag">Poison '+u.status.poisoned+'</span>':""}
        ${u.status.cover>0?'<span class="tag">Cover -'+u.status.cover+'</span>':""}
        ${u.shield>0?'<span class="tag">Shield '+u.shield+'</span>':""}
      </div>`;
    s.appendChild(el);
  }

  fill("player-primary", PF.primary); fill("player-secondary", PF.secondary); fill("player-support", PF.support);
  fill("ai-primary", AF.primary); fill("ai-secondary", AF.secondary); fill("ai-support", AF.support);

  const pb = $("#player-bench"); pb.innerHTML="";
  PF.bench.forEach(u=>{ const el=document.createElement("div"); el.className="card"; el.innerHTML=`<div class="name">${u.name}</div><div class="stats"><span>HP:${u.curHP}</span></div>`; pb.appendChild(el); });
  const ab = $("#ai-bench"); ab.innerHTML="";
  AF.bench.forEach(u=>{ const el=document.createElement("div"); el.className="card ai"; el.innerHTML=`<div class="name">${u.name}</div><div class="stats"><span>HP:${u.curHP}</span></div>`; ab.appendChild(el); });
}

function renderLog(){ const el=$("#log"); el.innerHTML = G.log.slice(-100).map(x=>`<div>${x}</div>`).join(""); el.scrollTop=el.scrollHeight; }
function updateTurnBanner(){ $("#turn-banner").textContent = (G.current==="player"?"Your turn":"AI turn"); }
function renderAll(){ renderGarden(); renderHands(); renderCombatBoards(); }

/* -------- Actions / Combat -------- */
function enableActionButtons(){
  const F = G.player.formation;
  const canP = unitCanAct(F.primary) && F.primary.curEN>=1;
  const canS = unitCanAct(F.secondary) && F.secondary.curEN>=1;
  const canPa = unitCanAct(F.primary) && F.primary.active && F.primary.curEN>=F.primary.active.cost;
  const canSa = unitCanAct(F.secondary) && F.secondary.active && F.secondary.curEN>=F.secondary.active.cost;
  const canUa = unitCanAct(F.support) && F.support.active && F.support.curEN>=F.support.active.cost;

  const twoSwaps = G.player.swaps>=2;
  $("#btn-ap").disabled = !canP || twoSwaps;
  $("#btn-as").disabled = !canS || twoSwaps;
  $("#btn-pp").disabled = !canPa;
  $("#btn-ps").disabled = !canSa;
  $("#btn-pu").disabled = !canUa;
  $("#btn-swap").disabled = false;
  $("#btn-end").disabled = false;
  $("#status-line").textContent = "Act with Primary, Secondary, and Support (any order).";
}

function doAttack(side, role){
  const F = side==="player"? G.player.formation : G.ai.formation;
  const EF = side==="player"? G.ai.formation : G.player.formation;
  const atk = F[role]; if(!unitCanAct(atk) || atk.curEN<1) return;

  const def = EF.primary && unitAlive(EF.primary) ? EF.primary :
              EF.secondary && unitAlive(EF.secondary) ? EF.secondary :
              EF.support;

  if(!def){ victory(side); return; }

  let dmg = calcDirectDamage(atk, def, side, role);
  def.curHP -= Math.max(0,dmg);
  atk.curEN -= 1;
  log(`${label(side)} ${role} ${atk.name} hits ${label(side==="player"?"ai":"player")} ${def.name} for ${dmg}.`);

  reactiveAfterHit(atk, def);

  postDamageCleanup();
  endIfExhaustedCheck(atk);

  renderCombatBoards(); enableActionButtons(); checkVictory();
}

function useActive(side, role){
  const F = side==="player"? G.player.formation : G.ai.formation;
  const EF = side==="player"? G.ai.formation : G.player.formation;
  const u = F[role]; if(!unitCanAct(u) || !u.active || u.curEN<u.active.cost) return;

  const a = u.active;
  const spend = ()=>{ u.curEN -= a.cost; endIfExhaustedCheck(u); };

  const ally = (t)=> (t==="self"? u : F.primary||F.secondary||F.support);
  const enemyFront = ()=> EF.primary && unitAlive(EF.primary)? EF.primary : (EF.secondary&&unitAlive(EF.secondary)? EF.secondary : EF.support);

  switch(a.kind){
    case "heal":{
      const tgt = ally(a.target);
      if(tgt){ const v=a.value||0; tgt.curHP=Math.min(tgt.hp, tgt.curHP+v); log(`${u.name} heals ${tgt.name} for ${v}.`); spend(); }
      break;
    }
    case "energize":{
      const tgt = a.target==="ally"? (F.primary||F.secondary||F.support) : u;
      if(tgt){ const v=a.value||1; tgt.curEN += v; log(`${u.name} energizes ${tgt.name} +${v} EN.`); spend(); }
      break;
    }
    case "stun":{
      const tgt = enemyFront(); if(tgt){ tgt.status.stunned=Math.max(tgt.status.stunned,(a.value||1)); log(`${u.name} stuns ${tgt.name} for ${a.value||1}.`); spend(); }
      break;
    }
    case "poison":{
      const tgt = enemyFront(); if(tgt){ tgt.status.poisoned += (a.value||1); log(`${u.name} poisons ${tgt.name} (${tgt.status.poisoned}).`); spend(); }
      break;
    }
    case "burn":{
      const tgt = enemyFront(); if(tgt && !(tgt.passive&&tgt.passive.kind==="burnImmune")){ tgt.status.burned = 1; log(`${u.name} applies Burn to ${tgt.name}.`); spend(); }
      break;
    }
    case "weaken":{
      const tgt = enemyFront(); if(tgt){ tgt.status.weakened=1; log(`${u.name} weakens ${tgt.name} (-5 next).`); spend(); }
      break;
    }
    case "cover":{
      const tgt = ally("ally"); if(tgt){ tgt.status.cover = Math.max(tgt.status.cover, a.value||5); log(`${u.name} covers ${tgt.name} (-${tgt.status.cover} next).`); spend(); }
      break;
    }
    case "root":{
      const tgt = enemyFront(); if(tgt){ tgt.status.rooted=Math.max(tgt.status.rooted,a.value||1); log(`${u.name} roots ${tgt.name}.`); spend(); }
      break;
    }
    case "drain":{
      const tgt = EF.primary; if(tgt){ const v=Math.min(tgt.curEN,(a.value||1)); tgt.curEN-=v; u.curEN+=v; log(`${u.name} drains ${v} EN from ${tgt.name}.`); spend(); }
      break;
    }
    case "seed":{
      const seed = {name:"Seedling", type:u.type, rarity:"Seed", energy:1, hp:10, atk:10, passive:null, active:null};
      const su = initUnit(seed); F.bench.push(su);
      log(`${u.name} seeds a 10/10 ${u.type} on your bench.`); spend(); break;
    }
  }

  renderCombatBoards(); enableActionButtons(); checkVictory();
}

function startSwapFlow(){
  const F = G.player.formation;
  if(F.primary && F.secondary && !F.primary.status.anchor && !F.secondary.status.anchor){
    [F.primary, F.secondary] = [F.secondary, F.primary];
    G.player.swaps++; log("You swapped Primary and Secondary.");
  } else if (F.secondary && F.support && !F.support.status.anchor){
    [F.secondary, F.support] = [F.support, F.secondary];
    G.player.swaps++; log("You swapped Secondary and Support.");
  } else {
    log("No valid swap available.");
    return;
  }
  renderCombatBoards(); enableActionButtons();
}

function endTurn(){
  applyEndOfTurnEffects("player");
  G.current = "ai"; updateTurnBanner();
  renderCombatBoards(); enableActionButtons();
  setTimeout(aiTurn, 250);
}

function applyEndOfTurnEffects(side){
  const F = side==="player"? G.player.formation : G.ai.formation;

  if(unitAlive(F.support) && F.support.passive && F.support.passive.kind==="vitalize"){
    const target = F.primary && unitAlive(F.primary)? F.primary : F.secondary;
    if(target){ target.curEN += (F.support.passive.value||1); log(`${label(side)} Support vitalizes ${target.name} +${F.support.passive.value||1} EN.`); }
  }
  if(unitAlive(F.primary) && F.primary.passive && F.primary.passive.kind==="regen"){
    F.primary.curHP = Math.min(F.primary.hp, F.primary.curHP + (F.primary.passive.value||0));
    log(`${label(side)} Primary regenerates ${(F.primary.passive.value||0)} HP.`);
  }

  ["primary","secondary","support"].forEach(r=>{
    const u = F[r]; if(!unitAlive(u)) return;
    if(u.status.poisoned>0){
      u.curHP -= 5;
      u.status.poisoned--;
      log(`${u.name} takes 5 poison damage (${u.status.poisoned} left).`);
    }
  });

  ["primary","secondary","support"].forEach(r=>{
    const u = F[r]; if(!u) return;
    if(u.exhausted){ u.curEN = u.energy; u.exhausted=false; log(`${u.name} refreshes to full energy.`); }
    if(u.curEN<=0 && !u.exhausted){ u.exhausted = true; }
  });

  if(side==="player") G.player.swaps=0; else G.ai.swaps=0;

  handleReplacements(side);
  checkVictory();
}

function handleReplacements(side){
  const F = side==="player"? G.player.formation : G.ai.formation;
  if(!unitAlive(F.primary)){
    if(unitAlive(F.secondary)){ F.primary = F.secondary; F.secondary = null; }
    else if(unitAlive(F.support)){ F.primary = F.support; F.support = null; }
  }
  if(!unitAlive(F.secondary) && unitAlive(F.support)){ F.secondary = F.support; F.support = null; }
  if(!unitAlive(F.support) && F.bench.length>0){
    const inU = F.bench.shift();
    inU.curEN = inU.energy; inU.exhausted=false;
    F.support = inU;
  }
}

function endIfExhaustedCheck(u){ if(u.curEN<=0){ u.exhausted=true; } }

function postDamageCleanup(){ /* hook for combos if needed */ }

function reactiveAfterHit(attacker, defender){
  if(attacker.firstBonus){ attacker.firstBonus=0; }
  if(defender.passive&&defender.passive.kind==="thorns"){ attacker.curHP -= (defender.passive.value||0); log(`${defender.name}'s Thorns deal ${(defender.passive.value||0)} back.`); }
  if(attacker.passive&&attacker.passive.kind==="spores" && Math.random()<0.2){ defender.status.weakened=1; log(`${defender.name} is Weakened (-5 next).`); }
}

function calcDirectDamage(atk, def, side, role){
  let dmg = atk.atk + (atk.firstBonus||0);
  if(ADV[atk.type]===def.type) dmg += 10;
  // swap penalty
  const swaps = side==="player"? G.player.swaps : G.ai.swaps;
  if(swaps===1 && (role==="primary"||role==="secondary")) dmg = Math.floor(dmg/2);
  // defender cover
  if(def.status.cover>0){ dmg = Math.max(0,dmg - def.status.cover); /* cover consumed on hit */ }
  // shield
  if(def.shield>0){ const ab=Math.min(def.shield,dmg); def.shield-=ab; dmg-=ab; }
  // steadfast
  if(def.passive&&def.passive.kind==="steadfast") dmg = Math.max(0, dmg - (def.passive.value||0));
  // weakened attacker
  if(atk.status.weakened>0){ dmg = Math.max(0, dmg - 5); /* consume */ }
  // burn on defender adds +10 once (unless water immune)
  if(def.status.burned>0 && !(def.passive&&def.passive.kind==="burnImmune")){ dmg += 10; }
  // consume one-time flags
  if(def.status.cover>0) def.status.cover=0;
  if(def.status.burned>0 && !(def.passive&&def.passive.kind==="burnImmune")) def.status.burned=0;
  if(atk.status.weakened>0) atk.status.weakened=0;
  return Math.max(0, Math.floor(dmg));
}

// A pure "prediction" version that does NOT mutate state
function predictDirectDamage(atk, def, swaps=0, role="primary"){
  let dmg = atk.atk + (atk.firstBonus||0);
  if(ADV[atk.type]===def.type) dmg += 10;
  if(swaps===1 && (role==="primary"||role==="secondary")) dmg = Math.floor(dmg/2);
  let cover = def.status.cover||0;
  let shield = def.shield||0;
  let weakened = atk.status.weakened>0;
  let burn = def.status.burned>0 && !(def.passive&&def.passive.kind==="burnImmune");

  if(cover>0){ dmg=Math.max(0,dmg-cover); cover=0; }
  if(shield>0){ const ab=Math.min(shield,dmg); shield-=ab; dmg-=ab; }
  if(def.passive&&def.passive.kind==="steadfast") dmg = Math.max(0, dmg - (def.passive.value||0));
  if(weakened) dmg = Math.max(0,dmg-5);
  if(burn) dmg += 10;

  return Math.max(0, Math.floor(dmg));
}

/* -------- Victory -------- */
function checkVictory(){
  const P = G.player.formation, A = G.ai.formation;
  const pAlive = [P.primary,P.secondary,P.support,...P.bench].some(unitAlive);
  const aAlive = [A.primary,A.secondary,A.support,...A.bench].some(unitAlive);
  if(!pAlive || !aAlive){
    const winner = pAlive? "You win! ðŸŒŸ" : "AI wins! ðŸ¤–";
    log("Game over â€” " + winner);
    $("#status-line").textContent = winner;
    disableAllActions();
  }
}

function disableAllActions(){
  ["#btn-ap","#btn-as","#btn-pp","#btn-ps","#btn-pu","#btn-swap","#btn-end"].forEach(id=> $(id).disabled = true);
}

/* -------- AI Turn (Aggressive + Defensive) -------- */
function aiTurn(){
  if(G.phase!=="combat") return;
  const F = G.ai.formation, E = G.player.formation;

  // 0) Defensive/offensive swap logic:
  // Save dying primary OR bring in better matchup if possible.
  tryAISwap(F, E);

  // 1) Support active (heal/energize/control) if high value
  tryAISupport(F, E);

  // 2) Primary: try to kill, else best value
  tryAIAttackOrActive(F, E, "primary");

  // 3) Secondary: try to kill, else best value
  tryAIAttackOrActive(F, E, "secondary");

  // 4) End turn
  applyEndOfTurnEffects("ai");
  G.current="player"; updateTurnBanner();
  renderCombatBoards(); enableActionButtons(); checkVictory();
}

function tryAISwap(F, E){
  if(!unitAlive(F.primary)) return; // will be replaced in end effects anyway
  if(G.ai.swaps>=2) return;

  const p = F.primary, s = F.secondary;
  // If primary is in lethal range from player's primary next turn, and secondary is healthier and not anchored -> swap
  if(s && unitAlive(s) && !p.status.anchor && !s.status.anchor){
    // estimate player's next primary damage against us
    const oppP = E.primary && unitAlive(E.primary) ? E.primary : null;
    const likelyDmg = oppP ? predictDirectDamage(oppP, p, 0, "primary") : 0;
    if(p.curHP <= Math.max(10, likelyDmg)){ // danger threshold
      [F.primary, F.secondary] = [F.secondary, F.primary];
      G.ai.swaps++; log("ðŸ¤– AI swaps Primary and Secondary (defensive).");
      return;
    }
  }

  // Offensive: if secondary has strong type advantage to enemy primary, swap forward
  if(s && unitAlive(s) && !p.status.anchor && !s.status.anchor && unitAlive(E.primary)){
    if(ADV[s.type]===E.primary.type && G.ai.swaps<2){
      [F.primary, F.secondary] = [F.secondary, F.primary];
      G.ai.swaps++; log("ðŸ¤– AI swaps to push type advantage.");
    }
  }
}

function tryAISupport(F, E){
  const u = F.support;
  if(!unitCanAct(u) || !u.active || u.curEN<u.active.cost) return;
  const a = u.active;

  // Healing priority: heal the lowest % HP ally if under 55% and heal >=8
  if(a.kind==="heal"){
    const targets = [F.primary,F.secondary,F.support].filter(unitAlive);
    if(targets.length){
      targets.sort((x,y)=>(x.curHP/x.hp)-(y.curHP/y.hp));
      const t = targets[0];
      const ratio = t.curHP/t.hp;
      const healV = a.value||0;
      if(ratio<0.55 && healV>=8){
        u.curEN -= a.cost; t.curHP = Math.min(t.hp, t.curHP + healV);
        log(`ðŸ¤– ${u.name} heals ${t.name} for ${healV}.`);
        endIfExhaustedCheck(u);
        return;
      }
    }
  }

  // Energize priority: if primary lacks energy to secure a kill this turn
  if(a.kind==="energize"){
    const target = F.primary && unitAlive(F.primary) ? F.primary : F.secondary;
    const enem = E.primary && unitAlive(E.primary) ? E.primary : (E.secondary&&unitAlive(E.secondary)?E.secondary:E.support);
    if(target && enem){
      const dmgNow = target.curEN>=1 ? predictDirectDamage(target, enem, G.ai.swaps, "primary") : 0;
      const lethal = enem.curHP <= dmgNow;
      if(!lethal && target.curEN<1){
        u.curEN -= a.cost; target.curEN += (a.value||1);
        log(`ðŸ¤– ${u.name} energizes ${target.name} +${(a.value||1)} EN.`);
        endIfExhaustedCheck(u);
        return;
      }
    }
  }

  // Control: stun/root the player's highest ATK live unit (aggressive tempo)
  if((a.kind==="stun"||a.kind==="root")){
    const candidates = [E.primary,E.secondary,E.support].filter(unitAlive);
    if(candidates.length){
      candidates.sort((x,y)=>y.atk-x.atk);
      const t = candidates[0];
      (a.kind==="stun") ? (t.status.stunned=Math.max(t.status.stunned, a.value||1))
                        : (t.status.rooted=Math.max(t.status.rooted, a.value||1));
      u.curEN -= a.cost;
      log(`ðŸ¤– ${u.name} uses ${a.kind} on ${t.name}.`);
      endIfExhaustedCheck(u);
      return;
    }
  }

  // Attrition when no immediate kill: poison/burn/weak/drain
  if(["poison","burn","weaken","drain","cover","seed"].includes(a.kind)){
    // simple: use on default targets
    useActive("ai","support");
  }
}

function tryAIAttackOrActive(F, E, role){
  const u = F[role];
  if(!unitAlive(u)) return;

  // choose the best enemy target among active row (pref primary)
  const targets = [E.primary,E.secondary,E.support].filter(unitAlive);
  if(targets.length===0) return;

  // 1) If attack can kill someone, do it (prefer killing Primary, else lowest HP kill)
  if(u.curEN>=1 && unitCanAct(u)){
    // check kills
    let kill = null;
    for(const t of targets){
      const dmg = predictDirectDamage(u, t, G.ai.swaps, role);
      if(t.curHP <= dmg){ kill = (kill==null || (t===E.primary)) ? t : kill; }
    }
    if(kill){
      // ensure attack hits that kill target: we only attack â€œfrontâ€ in our simple rules (Primary by default),
      // but we allow kill on whichever front exists in order (Primary > Secondary > Support)
      // Choose the target that is currently â€œfront-mostâ€ among kill-ables.
      const order = [E.primary,E.secondary,E.support].filter(x=>x&&kill&&x===kill);
      if(order.length){
        doAttack("ai", role);
        return;
      }
    }
  }

  // 2) If active can set up lethal (stun to deny counter, energize to enable strike, weaken to reduce damage, burn to amplify), try active first.
  if(unitCanAct(u) && u.active && u.curEN>=u.active.cost){
    const a = u.active;
    // aggressiveness: if burn/poison can push next attack into lethal range or if drain slows enemy primary with high EN
    if(a.kind==="burn"||a.kind==="poison"||a.kind==="weaken"||a.kind==="drain"||a.kind==="stun"||a.kind==="root"||a.kind==="energize"){
      // heuristic: use now if we can't attack (no EN) or if target would survive our attack
      let front = E.primary && unitAlive(E.primary)? E.primary : (E.secondary&&unitAlive(E.secondary)?E.secondary:E.support);
      const canAttack = u.curEN>=1;
      const dmg = canAttack ? predictDirectDamage(u, front, G.ai.swaps, role) : 0;
      const wouldKill = canAttack && front.curHP <= dmg;
      if(!wouldKill){
        useActive("ai", role);
        return;
      }
    }
  }

  // 3) Otherwise, attack the best value target (front-most available). Our attack function auto-targets front.
  if(unitCanAct(u) && u.curEN>=1){
    doAttack("ai", role);
    return;
  }

  // 4) If no action, try active as last resort
  if(unitCanAct(u) && u.active && u.curEN>=u.active.cost){
    useActive("ai", role);
  }
}

/* -------- Event/UI helpers -------- */
function renderAllDraft(){ renderGarden(); renderHands(); }
function renderAllCombat(){ renderCombatBoards(); enableActionButtons(); }

/* -------- Start ---------- */
newGame();

/* -------- Bind Garden click after newGame -------- */
document.addEventListener("click", (e)=>{
  // delegate garden card picks
  if(G.phase==="draft"){
    const cards = Array.from(document.querySelectorAll("#garden .card"));
    const idx = cards.indexOf(e.target.closest(".card"));
    if(idx>=0){ pickFromGarden(idx); }
  }
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Overgrowth</title>
<style>
body { font-family: Arial, sans-serif; background: #f0f8ff; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; }
h1 { text-align: center; }
#game { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 900px; }
#garden, #playerHand, #battlefield, #aiBattlefield { display: flex; flex-wrap: wrap; justify-content: center; margin: 10px; }
.card { width: 100px; height: 140px; border: 1px solid #333; border-radius: 8px; margin: 5px; background: #fff; position: relative; cursor: pointer; text-align: center; display: flex; flex-direction: column; justify-content: space-between; }
.card img { width: 80px; height: 60px; margin: 5px auto 0 auto; }
.card.hidden { background: #999; cursor: default; }
.card .energy { position: absolute; top: 5px; right: 5px; font-weight: bold; background: #ffeb3b; padding: 2px 4px; border-radius: 3px; }
.card .hp, .card .atk { font-weight: bold; }
#log { width: 90%; height: 200px; border: 1px solid #333; overflow-y: scroll; background: #fff; padding: 5px; margin: 10px; }
button { margin: 5px; padding: 5px 10px; font-size: 14px; }
</style>
</head>
<body>
<h1>Overgrowth</h1>
<div id="game">
  <div id="garden"></div>
  <div id="playerHand"></div>
  <div id="battlefield"></div>
  <div id="aiBattlefield"></div>
  <div>
    <button id="startBattleBtn" disabled>Start Battle</button>
    <button id="nextTurnBtn" disabled>Next Turn</button>
  </div>
  <div id="log"></div>
</div>
<script>
// --- Card Model ---
class Card {
    constructor(name, type, rarity, hp, atk, energy, passive='', active='') {
        this.name = name; this.type = type; this.rarity = rarity;
        this.maxHp = hp; this.hp = hp; this.atk = atk;
        this.energy = energy; this.maxEnergy = energy;
        this.passive = passive; this.active = active;
        this.status = []; this.role = null;
        this.imgSrc = this.generateImage();
    }
    generateImage() {
        const colors = {Sun:'#FFD700',Water:'#1E90FF',Thorn:'#228B22',Fungal:'#A52A2A',Normal:'#D3D3D3',Nocturnal:'#4B0082'};
        const canvas = document.createElement('canvas'); canvas.width=80; canvas.height=60;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = colors[this.type]||'#fff'; ctx.fillRect(0,0,80,60);
        ctx.fillStyle='#000'; ctx.font='10px Arial'; ctx.fillText(this.name, 5,30);
        return canvas.toDataURL();
    }
}

// --- Game Variables ---
const types=['Sun','Water','Thorn','Fungal','Normal','Nocturnal'];
const rarities=['Common','Uncommon','Rare','Legendary','Mythic'];
let gardenDeck=[],garden=[],playerHand=[],aiHand=[],battlefield=[],aiBattlefield=[];
let turn=0,logDiv=document.getElementById('log');

// Generate 60+ cards
for(let i=1;i<=60;i++){
    let t=types[Math.floor(Math.random()*types.length)];
    let r=rarities[Math.floor(Math.random()*rarities.length)];
    let hp=Math.floor(Math.random()*20)+20, atk=Math.floor(Math.random()*10)+5;
    let energy=Math.floor(Math.random()*3)+1;
    gardenDeck.push(new Card(t+'Plant'+i,t,r,hp,atk,energy));
}
shuffle(gardenDeck);

// --- Utilities ---
function shuffle(array){for(let i=array.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];}}
function log(msg){logDiv.innerHTML+=msg+'<br>'; logDiv.scrollTop=logDiv.scrollHeight;}

// --- Garden / Draft ---
function drawGarden(){garden=[];for(let i=0;i<6;i++){if(gardenDeck.length>0) garden.push(gardenDeck.pop());} renderGarden();}
function renderGarden(){
    const gardenDiv=document.getElementById('garden'); gardenDiv.innerHTML='';
    garden.forEach((card,i)=>{
        let div=document.createElement('div'); div.className='card';
        div.innerHTML=`<div class="energy">${card.energy}</div>
                       <img src="${card.imgSrc}" />
                       <div>${card.name}</div>
                       <div class="hp">HP:${card.hp}</div>
                       <div class="atk">ATK:${card.atk}</div>`;
        div.onclick=()=>pickCard(card,i); gardenDiv.appendChild(div);
    });
}
function pickCard(card,index){
    if(playerHand.length<6){ playerHand.push(card); garden.splice(index,1); renderHand(); renderGarden();
        if(playerHand.length<6) drawGarden(); if(playerHand.length==6){ log('Draft finished. AI picks hand.'); pickAIHand(); } } }
function renderHand(){
    const handDiv=document.getElementById('playerHand'); handDiv.innerHTML='<h3>Your Hand</h3>';
    playerHand.forEach(c=>{
        let div=document.createElement('div'); div.className='card';
        div.innerHTML=`<div class="energy">${c.energy}</div>
                       <img src="${c.imgSrc}" />
                       <div>${c.name}</div>
                       <div class="hp">HP:${c.hp}</div>
                       <div class="atk">ATK:${c.atk}</div>`; handDiv.appendChild(div);
    });
}

// --- AI Draft ---
function pickAIHand(){ aiHand=[]; while(aiHand.length<6 && gardenDeck.length>0){ aiHand.push(gardenDeck.pop()); }
log('AI hand selected.'); document.getElementById('startBattleBtn').disabled=false; }

// --- Battle Setup ---
function startBattle(){ log('Battle start!');
    battlefield = [playerHand[0],playerHand[1],playerHand[2]];
    aiBattlefield = [aiHand[0],aiHand[1],aiHand[2]];
    renderBattlefield();
    document.getElementById('startBattleBtn').disabled=true;
    document.getElementById('nextTurnBtn').disabled=false;
}
function renderBattlefield(){
    const bfDiv=document.getElementById('battlefield'); bfDiv.innerHTML='<h3>Your Battlefield</h3>';
    battlefield.forEach(c=>{
        let div=document.createElement('div'); div.className='card';
        div.innerHTML=`<div class="energy">${c.energy}</div>
                       <img src="${c.imgSrc}" />
                       <div>${c.name}</div>
                       <div class="hp">HP:${c.hp}</div>
                       <div class="atk">ATK:${c.atk}</div>`; bfDiv.appendChild(div);
    });
    const aibfDiv=document.getElementById('aiBattlefield'); aibfDiv.innerHTML='<h3>Enemy Battlefield</h3>';
    aiBattlefield.forEach(c=>{
        let div=document.createElement('div'); div.className='card hidden';
        div.innerHTML=`<div class="energy">?</div>
                       <img src="" />
                       <div>Hidden</div>
                       <div class="hp">HP:?</div>
                       <div class="atk">ATK:?</div>`; aibfDiv.appendChild(div);
    });
}

// --- Battle Turn ---
document.getElementById('startBattleBtn').onclick=startBattle;
document.getElementById('nextTurnBtn').onclick=nextTurn;

function nextTurn(){ if(turn==0){ playerAttack(); turn=1; } else { aiAttack(); turn=0; } renderBattlefield(); checkVictory(); }

function playerAttack(){ if(battlefield.length>0 && aiBattlefield.length>0){
    let attacker=battlefield[0], defender=aiBattlefield[0];
    let damage=attacker.atk+typeAdvantage(attacker.type,defender.type);
    defender.hp-=damage;
    log(`Player ${attacker.name} attacks AI ${defender.name} for ${damage} damage.`);
    if(defender.hp<=0){ aiBattlefield.shift(); log(`AI ${defender.name} defeated!`); }
}}

function aiAttack(){ if(aiBattlefield.length>0 && battlefield.length>0){
    // Aggressive if player HP high, defensive if player low
    let attacker=aiBattlefield[0]; let defender=battlefield[0];
    let damage=attacker.atk+typeAdvantage(attacker.type,defender.type);
    defender.hp-=damage;
    log(`AI ${attacker.name} attacks Player ${defender.name} for ${damage} damage.`);
    if(defender.hp<=0){ battlefield.shift(); log(`Player ${defender.name} defeated!`); }
}}

// --- Type Advantage ---
function typeAdvantage(att,defend){ const adv={Nocturnal:'Fungal',Fungal:'Normal',Normal:'Thorn',Thorn:'Water',Water:'Sun',Sun:'Nocturnal'};
    return adv[att]==defend?10:0;
}

// --- Victory Check ---
function checkVictory(){ if(battlefield.length==0){ log('AI Wins!'); document.getElementById('nextTurnBtn').disabled=true; }
else if(aiBattlefield.length==0){ log('Player Wins!'); document.getElementById('nextTurnBtn').disabled=true; } }

// --- Start ---
drawGarden();
</script>
</body>
</html>o
