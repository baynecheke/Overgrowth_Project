<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Overgrowth - Full Game</title>
<style>
body { margin:0; font-family:'Segoe UI',sans-serif; background:#e8f5e9; display:flex; justify-content:center; align-items:center; min-height:100vh; overflow-x:hidden;}
#loadingScreen { position:absolute; width:100%; height:100%; background:url('https://i.imgur.com/1rYv7jk.png') center/cover no-repeat; display:flex; justify-content:center; align-items:center; font-size:3em; color:white; text-shadow:2px 2px 6px black; z-index:10; }
#gameContainer { display:none; flex-direction:column; align-items:center; width:100%; max-width:1200px; }
.board { display:flex; justify-content:space-between; width:100%; margin-top:20px; }
.playerBoard { display:flex; flex-direction:column; align-items:center; }
.cardsRow { display:flex; margin:5px 0; }
.card { width:120px; height:180px; background:white; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.3); margin:5px; position:relative; display:flex; flex-direction:column; justify-content:space-between; padding:5px; font-size:12px; cursor:pointer; transition:transform 0.3s; }
.card:hover { transform: scale(1.05); }
.card .name { font-weight:bold; text-align:center; }
.card .stats { display:flex; justify-content:space-between; font-size:11px; }
.card .hpBar { height:10px; width:100%; background:#ddd; border-radius:5px; overflow:hidden; position:relative; }
.card .hpFill { height:100%; background:#f44336; transition:width 0.5s; }
.card .energyBar { height:6px; width:100%; background:#ddd; border-radius:3px; overflow:hidden; margin-top:2px; }
.card .energyFill { height:100%; background:#ffeb3b; transition:width 0.5s; }
.card .status { position:absolute; bottom:5px; left:5px; font-size:10px; color:#333; }
.damagePop { position:absolute; color:red; font-weight:bold; animation:pop 0.8s ease-out forwards; }
.healPop { position:absolute; color:green; font-weight:bold; animation:pop 0.8s ease-out forwards; }
@keyframes pop { 0% {opacity:1; transform:translateY(0);} 100% {opacity:0; transform:translateY(-30px);} }
button { margin:10px; padding:10px 20px; font-size:16px; border-radius:5px; border:none; background:#4caf50; color:white; cursor:pointer; }
button:hover { background:#45a049; }
#garden { display:flex; flex-wrap:wrap; justify-content:center; margin-top:10px; }
#combatLog { max-height:200px; overflow-y:auto; width:90%; background:#fff; padding:10px; margin-top:10px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.2); font-size:14px; }
.glow { animation:glow 0.6s ease-in-out; }
@keyframes glow { 0%{box-shadow:0 0 0px yellow;} 50%{box-shadow:0 0 15px yellow;} 100%{box-shadow:0 0 0px yellow;} }
</style>
</head>
<body>
<div id="loadingScreen">Loading...</div>
<div id="gameContainer">
<h1>Overgrowth</h1>
<div id="garden"></div>
<button id="startCombat">Start Combat</button>
<div class="board">
<div class="playerBoard" id="playerBoard">
<h2>You</h2>
<div class="cardsRow" id="playerPrimary"></div>
<div class="cardsRow" id="playerSecondary"></div>
<div class="cardsRow" id="playerSupport"></div>
<div class="cardsRow" id="playerBench"></div>
</div>
<div class="playerBoard" id="aiBoard">
<h2>AI</h2>
<div class="cardsRow" id="aiPrimary"></div>
<div class="cardsRow" id="aiSecondary"></div>
<div class="cardsRow" id="aiSupport"></div>
<div class="cardsRow" id="aiBench"></div>
</div>
</div>
<div id="combatLog"></div>
</div>
<script>
setTimeout(() => {
    document.getElementById('loadingScreen').style.display='none';
    document.getElementById('gameContainer').style.display='flex';
    initGame();
}, 6000);

// Type and Advantage
const types=['Sun','Water','Thorn','Fungal','Normal','Nocturnal'];
const typeAdvantage={'Nocturnal':'Fungal','Fungal':'Normal','Normal':'Thorn','Thorn':'Water','Water':'Sun','Sun':'Nocturnal'};

// Game Variables
let gardenDeck=[], playerDeck=[], aiDeck=[], combatLog=[];
let playerFormation={}, aiFormation={};

// Logging
function log(msg){ combatLog.push(msg); const logEl=document.getElementById('combatLog'); logEl.innerHTML=combatLog.join('<br>'); logEl.scrollTop=logEl.scrollHeight; }

// Create a generic card
function createCard(name){
    const type=types[Math.floor(Math.random()*types.length)];
    const hp=Math.floor(Math.random()*20)+10;
    const atk=Math.floor(Math.random()*10)+5;
    const energy=Math.floor(Math.random()*3)+1;
    return {
        name,type,hp,maxHp:hp,atk,baseAtk:atk,energy,maxEnergy:energy,exhausted:false,statuses:[],
        passive:function(self,allyTeam,enemyTeam){},
        active:function(self,allyTeam,enemyTeam){
            if(self.energy>=1){
                let target=allyTeam.find(c=>c&&c.hp<c.maxHp);
                if(target){ target.hp=Math.min(target.maxHp,target.hp+5); self.energy-=1; showHeal(target,'+5'); log(`${self.name} heals ${target.name} 5 HP.`);}
            }
        }
    };
}

// Initialize Game
function initGame(){
    const garden=document.getElementById('garden'); garden.innerHTML='';
    const cardNames=['Rose','Cactus','Mushroom','Sunflower','Nightshade','Fern','Lily','Ivy','Daisy','Orchid','Bamboo','Tulip'];
    gardenDeck=cardNames.map(name=>createCard(name));
    // Drafting Phase 1
    gardenDeck.slice(0,6).forEach(card=>{
        const el=createCardElement(card);
        el.onclick=()=>{ if(playerDeck.length<3){playerDeck.push(card); garden.removeChild(el);} };
        garden.appendChild(el);
    });
    // AI drafts 3 cards avoiding overlap
    aiDeck=aiDraft(3,gardenDeck.slice(6));
}

// AI Drafting Logic
function aiDraft(n,cards){
    let selected=[];
    while(selected.length<n){
        let best=cards.reduce((a,b)=> (b.hp+b.atk)>(a.hp+a.atk)?b:a );
        selected.push(best); cards=cards.filter(c=>c!==best);
    }
    return selected;
}

// Create Card Element
function createCardElement(card){
    const el=document.createElement('div'); el.classList.add('card');
    el.innerHTML=`<div class="name">${card.name}</div>
    <div class="stats"><span>${card.type}</span><span>ATK:${card.atk}</span></div>
    <div class="hpBar"><div class="hpFill" style="width:${(card.hp/card.maxHp)*100}%"></div></div>
    <div class="energyBar"><div class="energyFill" style="width:${(card.energy/card.maxEnergy)*100}%"></div></div>
    <div class="status">${card.statuses.join(', ')}</div>`;
    return el;
}

// Start Combat
document.getElementById('startCombat').onclick=()=>{
    if(playerDeck.length!==3){alert('Pick 3 cards'); return;}
    setupCombat();
}

// Setup Combat Phase
function setupCombat(){
    playerFormation.primary=playerDeck[0];
    playerFormation.secondary=playerDeck[1];
    playerFormation.support=playerDeck[2];
    playerFormation.bench=[];
    aiFormation.primary=aiDeck[0];
    aiFormation.secondary=aiDeck[1];
    aiFormation.support=aiDeck[2];
    aiFormation.bench=[];
    log("Combat begins!");
    updateBoard();
    setTimeout(combatTurn,1000);
}

// Update Board
function updateBoard(){
    function render(containerId, formation){
        const container=document.getElementById(containerId); container.innerHTML='';
        ['primary','secondary','support'].forEach(pos=>{ if(formation[pos]) container.appendChild(createCardElement(formation[pos])); });
        formation.bench.forEach(card=>container.appendChild(createCardElement(card)));
    }
    render('playerPrimary',playerFormation); render('playerSecondary',playerFormation);
    render('playerSupport',playerFormation); render('playerBench',playerFormation);
    render('aiPrimary',aiFormation); render('aiSecondary',aiFormation);
    render('aiSupport',aiFormation); render('aiBench',aiFormation);
}

// Show Damage/Healing
function showDamage(card,amount){
    const dmg=document.createElement('div'); dmg.classList.add('damagePop'); dmg.textContent=amount;
    document.body.appendChild(dmg); setTimeout(()=>{document.body.removeChild(dmg);},800);
}
function showHeal(card,amount){
    const heal=document.createElement('div'); heal.classList.add('healPop'); heal.textContent=amount;
    document.body.appendChild(heal); setTimeout(()=>{document.body.removeChild(heal);},800);
}

// Combat Turn
function combatTurn(){
    if(!playerFormation.primary||!aiFormation.primary){ checkVictory(); return;}
    playerTurn();
    setTimeout(()=>{ if(!checkVictory()){ aiTurn(); if(!checkVictory()) setTimeout(combatTurn,1000); } },1000);
}

function playerTurn(){ turn(playerFormation,aiFormation,true); }
function aiTurn(){ turn(aiFormation,playerFormation,false,true); }

// Turn Logic
function turn(attackerTeam,defenderTeam,isPlayer,ai=false){
    ['primary','secondary','support'].forEach(pos=>{
        let attacker=attackerTeam[pos];
        if(attacker && !attacker.exhausted){
            // AI healing logic
            if(ai && attacker.hp<attacker.maxHp/2 && attacker.energy>=1){
                attacker.active(attacker,Object.values(attackerTeam),Object.values(defenderTeam));
            } else if(attacker.energy>=1 && defenderTeam.primary){
                let defender=defenderTeam.primary;
                if(ai){
                    let targets=[defenderTeam.primary,defenderTeam.secondary,defenderTeam.support].filter(c=>c);
                    defender=targets.reduce((a,b)=>a.hp<b.hp?a:b);
                }
                let dmg=attacker.atk;
                if(typeAdvantage[attacker.type]===defender.type) dmg+=10;
                if(defender.statuses.includes('Weakened')) dmg-=5;
                defender.hp-=dmg; attacker.energy-=1;
                showDamage(defender,dmg);
                log(`${attacker.name} attacks ${defender.name} for ${dmg} damage.`);
                if(defender.hp<=0){ shiftFormation(defenderTeam); log(`${defender.name} defeated!`); }
            }
            if(attacker.energy<=0){ attacker.exhausted=true; attacker.energy=0; log(`${attacker.name} is exhausted.`);}
        }
    });
    Object.values(attackerTeam).forEach(c=>{ if(c && c.exhausted){ c.energy=c.maxEnergy; c.exhausted=false; log(`${c.name} regains full energy.`); }});
    updateBoard();
}

// Shift Formation When Plant Dies
function shiftFormation(team){
    team.primary=team.secondary;
    team.secondary=team.support;
    team.support=team.bench.shift()||null;
}

// Victory Check
function checkVictory(){
    if(!playerFormation.primary){ alert('AI Wins!'); log('AI Wins!'); return true;}
    if(!aiFormation.primary){ alert('You Win!'); log('You Win!'); return true;}
    return false;
}
</script>
</body>
</html>
