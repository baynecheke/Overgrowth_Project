<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>Overgrowth — Web Prototype</title>
<style>
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:#0f172a;color:#e2e8f0}
#app{max-width:1100px;margin:0 auto;padding:12px}
header{display:flex;align-items:center;justify-content:space-between}
h1{margin:8px 0}
.pill{padding:4px 10px;border-radius:999px;background:#1e293b;opacity:.9;font-size:.9rem}
main{margin-top:8px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
button{border:0;padding:10px 14px;border-radius:10px;background:#22c55e;color:#062;cursor:pointer;font-weight:700}
button[disabled]{opacity:.6;cursor:not-allowed;filter:grayscale(.3)}
.card{width:160px;background:#111827;border:2px solid #334155;border-radius:12px;padding:8px;position:relative}
.card .name{font-weight:700}
.card .meta{font-size:.8rem;opacity:.8}
.card .stats{display:flex;justify-content:space-between;margin-top:4px}
.card .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
.tag{padding:2px 6px;border-radius:6px;background:#1f2937;font-size:.75rem}
.card-row,.bench-row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
.garden-wrap{margin-top:10px;padding:8px;border:1px dashed #334155;border-radius:10px}
.hidden{display:none}
.hands .hand{flex:1;min-width:280px}
.board{display:flex;gap:12px;margin:8px 0}
.column{flex:1}
.slot{min-height:180px;border:2px dashed #334155;border-radius:12px;padding:6px;display:flex;align-items:center;justify-content:center}
.boards{display:grid;grid-template-columns:1fr;gap:12px}
.active-row .slot{min-height:190px}
#action-panel{margin-top:12px;padding:10px;border:1px solid #334155;border-radius:12px;background:#0b1220}
#log{margin-top:10px;max-height:220px;overflow:auto;font-family:ui-monospace,monospace;background:#0a0f1b;padding:8px;border-radius:8px;font-size:.9rem}
#turn-banner{padding:8px;border-radius:8px;background:#1f2937;margin-bottom:8px}
footer{margin-top:16px;opacity:.7}
.card.selectable{outline:2px solid #22c55e}
.card.ai{border-color:#64748b}
.slot.highlight{background:#0b1329}
#status-line{margin:6px 0;opacity:.9}
@media (min-width:900px){.boards{grid-template-columns:1fr 1fr}}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>🌿 Overgrowth</h1>
    <div class="pill">v1.0 single-file prototype</div>
  </header>

  <main>
    <section id="setup">
      <h2>Gardening Phase</h2>
      <div class="row">
        <button id="btn-new">New Game</button>
        <button id="btn-help">Help / Rules</button>
      </div>
      <div id="help" class="hidden">
        <p>Draft from the Garden of 6 face-up cards. You and the AI draft until both have 6 cards.
          The AI **draws all of its cards from the Garden** and completes its drafting automatically.</p>
        <details>
          <summary>Implemented rules</summary>
          <ul>
            <li>Types loop (Nocturnal &gt; Fungal &gt; Normal &gt; Thorn &gt; Water &gt; Sun &gt; Nocturnal), +10 on direct attacks.</li>
            <li>Energy/exhaustion: Attack costs 1 EN; actives cost listed EN; at 0 EN you are exhausted next turn, then refill.</li>
            <li>Formations: Primary, Secondary, Support; Bench x3. Bench enters with full energy; bench energy not tracked.</li>
            <li>Statuses: Stunned, Rooted, Weakened, Burned, Poisoned X, Cover, Anchor (cannot move).</li>
            <li>Swap penalties: 1 swap → only one frontline attack at half dmg; 2 swaps → no frontline attacks.</li>
            <li>Victory: defeat all enemy plants.</li>
          </ul>
        </details>
      </div>

      <div class="garden-wrap">
        <h3>Garden (6 face-up)</h3>
        <div id="garden" class="card-row"></div>
        <div class="row">
          <button id="btn-flip" disabled>Flip / Refill Garden</button>
        </div>
      </div>

      <div class="row hands">
        <div class="hand">
          <h3>Your Drafted Cards (<span id="phc">0</span>/6)</h3>
          <div id="pHand" class="card-row"></div>
        </div>
        <div class="hand">
          <h3>AI Drafted (hidden)</h3>
          <div id="aHand" class="card-row hidden"></div>
        </div>
      </div>
      <div class="row">
        <button id="btn-arrange" disabled>Finish Drafting & Arrange</button>
      </div>
    </section>

    <section id="formation" class="hidden">
      <h2>Arrange Formation</h2>
      <p>Tap a card in your hand then tap a slot. Fill Primary, Secondary, and Support; the rest go to Bench.</p>
      <div class="board">
        <div class="column"><h4>Support</h4><div class="slot" data-slot="player-support"></div></div>
        <div class="column"><h4>Primary</h4><div class="slot" data-slot="player-primary"></div></div>
        <div class="column"><h4>Secondary</h4><div class="slot" data-slot="player-secondary"></div></div>
      </div>
      <h4>Bench (auto from remaining)</h4>
      <div id="player-bench-setup" class="bench-row"></div>
      <div class="row"><button id="btn-begin" disabled>Begin Combat</button></div>
    </section>

    <section id="combat" class="hidden">
      <h2>Combat Phase</h2>
      <div id="turn-banner"></div>
      <div class="boards">
        <div class="side">
          <h3>AI</h3>
          <div class="row active-row">
            <div class="slot" data-slot="ai-support"></div>
            <div class="slot" data-slot="ai-primary"></div>
            <div class="slot" data-slot="ai-secondary"></div>
          </div>
          <div id="ai-bench" class="bench-row"></div>
        </div>
        <div class="side">
          <h3>You</h3>
          <div class="row active-row">
            <div class="slot" data-slot="player-support"></div>
            <div class="slot" data-slot="player-primary"></div>
            <div class="slot" data-slot="player-secondary"></div>
          </div>
          <div id="player-bench" class="bench-row"></div>
        </div>
      </div>

      <div id="action-panel">
        <h3>Your Actions</h3>
        <div id="status-line"></div>
        <div class="row">
          <button id="btn-ap" disabled>Attack (Primary)</button>
          <button id="btn-as" disabled>Attack (Secondary)</button>
        </div>
        <div class="row">
          <button id="btn-pp" disabled>Use Active (Primary)</button>
          <button id="btn-ps" disabled>Use Active (Secondary)</button>
          <button id="btn-pu" disabled>Use Active (Support)</button>
        </div>
        <div class="row">
          <button id="btn-swap" disabled>Swap / Reorder</button>
          <button id="btn-end" disabled>End Turn</button>
        </div>
        <div id="log"></div>
      </div>
    </section>
  </main>

  <footer>© Overgrowth prototype — single HTML file for GitHub Pages</footer>
</div>

<script>
/* =========================
   Overgrowth — Single-file Web Prototype
   =========================
   - AI drafts all of its cards from the Garden and completes drafting automatically.
   - Turn-based combat with Energy & Exhaustion, statuses, swap penalties.
   - Type advantage loop applied on direct attacks only (+10).
   - Mobile-friendly taps; no drag & drop required.
*/

const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

/* -------- Card DB (seed set, auto-extended) -------- */
const TYPES = ["Sun","Water","Thorn","Fungal","Normal","Nocturnal"];
const ADV = { Nocturnal:"Fungal", Fungal:"Normal", Normal:"Thorn", Thorn:"Water", Water:"Sun", Sun:"Nocturnal" };

const BASE = [
  {name:"Solar Sprout", type:"Sun", rarity:"Common", energy:2, hp:30, atk:10, passive:{kind:"burnShield",text:"-10 from next hit if fresh"}, active:{cost:2,kind:"energize",value:1,target:"ally",text:"Energize ally +1"}},
  {name:"Helio Bloom", type:"Sun", rarity:"Uncommon", energy:3, hp:35, atk:12, passive:{kind:"atkAura",value:2,text:"+2 ATK to adjacent"}, active:{cost:2,kind:"burn",value:1,target:"enemy",text:"Burn: +10 taken next hit"}},
  {name:"Dawn Cactus", type:"Sun", rarity:"Rare", energy:3, hp:40, atk:12, passive:{kind:"anchor",text:"Anchor"}, active:{cost:3,kind:"heal",value:10,target:"ally",text:"Heal 10"}},

  {name:"Brook Lily", type:"Water", rarity:"Common", energy:2, hp:28, atk:10, passive:{kind:"burnImmune",text:"Immune to Burn"}, active:{cost:2,kind:"heal",value:8,target:"ally",text:"Heal 8"}},
  {name:"Tide Fern", type:"Water", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"vitalize",value:1,text:"On start: give +1 EN to ally"}, active:{cost:2,kind:"stun",value:1,target:"enemy",text:"Stun 1"}},
  {name:"Abyss Lotus", type:"Water", rarity:"Rare", energy:3, hp:36, atk:12, passive:{kind:"regen",value:3,text:"End turn: regen 3"}, active:{cost:3,kind:"poison",value:2,target:"enemy",text:"Poison 2"}},

  {name:"Bramble Guard", type:"Thorn", rarity:"Common", energy:2, hp:40, atk:10, passive:{kind:"thorns",value:5,text:"Reflect 5 on hit"}, active:{cost:2,kind:"cover",value:5,target:"ally",text:"Cover -5"}},
  {name:"Spine Oak", type:"Thorn", rarity:"Uncommon", energy:3, hp:45, atk:12, passive:{kind:"fortify",value:5,text:"Shield 5 at start"}, active:{cost:3,kind:"root",value:1,target:"enemy",text:"Root 1"}},
  {name:"Citadel Briar", type:"Thorn", rarity:"Rare", energy:3, hp:50, atk:12, passive:{kind:"anchor",text:"Anchor"}, active:{cost:2,kind:"energize",value:2,target:"ally",text:"Energize +2"}},

  {name:"Myco Puff", type:"Fungal", rarity:"Common", energy:2, hp:30, atk:10, passive:{kind:"spores",value:2,text:"20% weaken on hit"}, active:{cost:2,kind:"poison",value:1,target:"enemy",text:"Poison 1"}},
  {name:"Glow Cap", type:"Fungal", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"nightAlly",value:2,text:"+2 ATK if Nocturnal ally"}, active:{cost:2,kind:"seed",value:1,target:"self",text:"Seed 1"}},
  {name:"Rot Lord", type:"Fungal", rarity:"Rare", energy:3, hp:38, atk:12, passive:{kind:"decay",value:2,text:"+2 damage taken by enemies"}, active:{cost:3,kind:"drain",value:1,target:"enemy",text:"Drain 1 EN (Primary)"}},

  {name:"Meadow Bud", type:"Normal", rarity:"Common", energy:2, hp:30, atk:12, passive:{kind:"balanced",text:"—"}, active:{cost:2,kind:"heal",value:6,target:"ally",text:"Heal 6"}},
  {name:"Field Rowan", type:"Normal", rarity:"Uncommon", energy:3, hp:34, atk:12, passive:{kind:"chain",text:"Chain display"}, active:{cost:2,kind:"energize",value:1,target:"ally",text:"Energize +1"}},
  {name:"Highland Birch", type:"Normal", rarity:"Rare", energy:3, hp:36, atk:14, passive:{kind:"steadfast",value:2,text:"-2 dmg from attacks"}, active:{cost:3,kind:"weaken",value:1,target:"enemy",text:"Weaken -5 next"}},

  {name:"Night Shade", type:"Nocturnal", rarity:"Common", energy:2, hp:28, atk:12, passive:{kind:"evasive",value:10,text:"10% dodge"}, active:{cost:2,kind:"stun",value:1,target:"enemy",text:"Stun 1"}},
  {name:"Moon Orchid", type:"Nocturnal", rarity:"Uncommon", energy:3, hp:32, atk:12, passive:{kind:"shadowAtk",value:2,text:"+2 first strike (flavor)"}, active:{cost:2,kind:"energize",value:2,target:"self",text:"Self +2 EN"}},
  {name:"Eclipse Ivy", type:"Nocturnal", rarity:"Rare", energy:3, hp:34, atk:14, passive:{kind:"ambush",value:4,text:"+4 first attack"}, active:{cost:3,kind:"seed",value:1,target:"self",text:"Seed 1"}}
];

// extend to ~60+ cards by cloning variants
let ALL = []; let idc=1;
for (const b of BASE){
  const push = (obj)=>{ ALL.push({...obj,id:idc++}); };
  push(b);
  const copies = b.rarity==="Common"?3 : b.rarity==="Uncommon"?2 : 1;
  for(let i=0;i<copies;i++){
    const v = {...b};
    v.name = b.name+" +"+(i+1);
    v.hp = b.hp + (i%2===0?2:0);
    v.atk = b.atk + (i%2?1:0);
    push(v);
  }
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a;}
const clone = o => JSON.parse(JSON.stringify(o));

/* -------- Game State -------- */
const G = {
  phase:"draft",
  deck:[],
  garden:[],
  player:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
  ai:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
  current:"player",
  log:[]
};

function log(msg){ G.log.push(msg); renderLog(); }

/* -------- UI bootstrap -------- */
$("#btn-help").onclick = ()=> $("#help").classList.toggle("hidden");
$("#btn-new").onclick = newGame;
$("#btn-flip").onclick = flipOrRefill;
$("#btn-arrange").onclick = endDraftToArrange;
$("#btn-begin").onclick = beginCombat;

$("#btn-ap").onclick = ()=> doAttack("player","primary");
$("#btn-as").onclick = ()=> doAttack("player","secondary");
$("#btn-pp").onclick = ()=> useActive("player","primary");
$("#btn-ps").onclick = ()=> useActive("player","secondary");
$("#btn-pu").onclick = ()=> useActive("player","support");
$("#btn-swap").onclick = ()=> startSwapFlow();
$("#btn-end").onclick = ()=> endTurn();

/* -------- New Game / Drafting -------- */
function newGame(){
  Object.assign(G,{
    phase:"draft",
    deck:shuffle(ALL.map(clone)),
    garden:[],
    player:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
    ai:{hand:[], formation:{primary:null,secondary:null,support:null,bench:[]}, acted:{}, swaps:0},
    current:"player",
    log:[]
  });
  $("#setup").classList.remove("hidden");
  $("#formation").classList.add("hidden");
  $("#combat").classList.add("hidden");
  $("#btn-flip").disabled = false;
  $("#btn-arrange").disabled = true;
  $("#phc").textContent = "0";
  renderGarden();
  renderHands();
  log("🌱 New game. Flip to reveal the Garden.");
}

function flipOrRefill(){
  // always maintain 6 face-up for drafting (if deck allows)
  while(G.garden.length<6 && G.deck.length>0){ G.garden.push(G.deck.pop()); }
  $("#btn-flip").disabled = true;
  log("🌼 Garden ready. Draft until both have 6. AI drafts automatically.");
  // Begin auto-drafting flow: player taps cards; AI responds until both reach 6
  renderGarden();
}

/* Player pick from garden */
function pickFromGarden(idx){
  if(G.phase!=="draft") return;
  const c = G.garden.splice(idx,1)[0];
  if(!c) return;
  G.player.hand.push(c);
  log(`You drafted ${c.name}.`);
  refillGardenForDraft();
  aiDraftUntilBalanced();
  updateDraftButtons();
  renderAll();
}

function refillGardenForDraft(){
  while(G.garden.length<6 && G.deck.length>0 && (G.player.hand.length<6 || G.ai.hand.length<6)){
    G.garden.push(G.deck.pop());
  }
}

function aiDraftUntilBalanced(){
  // AI drafts until it has either caught up to player's hand size
  // OR until both reach 6; always from the Garden.
  while(G.ai.hand.length < Math.min(G.player.hand.length,6)){
    aiPickOnce();
    refillGardenForDraft();
  }
  // If player already at 6, let AI finish to 6
  while(G.player.hand.length>=6 && G.ai.hand.length<6){
    aiPickOnce();
    refillGardenForDraft();
  }
}

function aiPickOnce(){
  if(G.garden.length===0) return;
  const ranked = G.garden.map((c,i)=>({c,i,score: aiScore(c)})).sort((a,b)=>b.score-a.score);
  const pick = ranked[0];
  const card = G.garden.splice(pick.i,1)[0];
  G.ai.hand.push(card);
  log(`🤖 AI drafted ${card.name}.`);
}

function aiScore(c){
  let s = 0;
  if(c.type==="Thorn") s+=3;
  if(c.rarity==="Rare") s+=3;
  if(c.rarity==="Uncommon") s+=1;
  s += (c.hp/10)+(c.atk/5)+c.energy;
  // prefer new types
  const counts = {};
  for(const h of G.ai.hand){ counts[h.type]=(counts[h.type]||0)+1; }
  s += (counts[c.type]||0)==0 ? 2 : 0;
  return s;
}

function updateDraftButtons(){
  $("#phc").textContent = G.player.hand.length+"/6";
  $("#btn-arrange").disabled = !(G.player.hand.length>=6 && G.ai.hand.length>=6);
}

function endDraftToArrange(){
  G.phase="arrange";
  $("#setup").classList.add("hidden");
  $("#formation").classList.remove("hidden");
  renderArrange();
  aiArrange();
}

let selectedFromHand = null;
function renderArrange(){
  const hand = $("#pHand"); hand.innerHTML="";
  G.player.hand.forEach((c,i)=>{
    const el = renderCard(c);
    el.classList.add("selectable");
    el.onclick = ()=>{ selectedFromHand = {i}; highlightSlots(true); };
    hand.appendChild(el);
  });

  $$(".slot[data-slot^='player-']").forEach(s=>{
    s.innerHTML = "(empty)";
    s.onclick = ()=>{
      if(!selectedFromHand) return;
      const role = s.dataset.slot.split("-")[1];
      placeIntoRole(role, G.player.hand.splice(selectedFromHand.i,1)[0], "player");
      selectedFromHand = null; highlightSlots(false); renderArrange();
    };
  });

  // show what will go to bench
  const benchHold = $("#player-bench-setup"); benchHold.innerHTML="";
  G.player.hand.forEach(c=> benchHold.appendChild(renderMini(c)));

  const ready = G.player.formation.primary && G.player.formation.secondary && G.player.formation.support;
  $("#btn-begin").disabled = !ready || (G.player.hand.length!==3);
}

function highlightSlots(on){
  $$(".slot[data-slot^='player-']").forEach(s => s.classList.toggle("highlight", !!on));
}

function placeIntoRole(role, card, side){
  const u = initUnit(card);
  const F = side==="player" ? G.player.formation : G.ai.formation;
  F[role] = u;
}

function aiArrange(){
  // simple: highest HP -> primary, highest ATK -> secondary, support = healer/energizer else highest EN
  const picks = G.ai.hand.slice();
  picks.sort((a,b)=>b.hp-a.hp); const P = initUnit(picks.shift());
  picks.sort((a,b)=>b.atk-a.atk); const S = initUnit(picks.shift());
  let idx = picks.findIndex(x=> x.active && (x.active.kind==="heal"||x.active.kind==="energize"));
  if(idx<0) idx=0;
  const U = initUnit(picks.splice(idx,1)[0]);
  G.ai.formation = {primary:P, secondary:S, support:U, bench:picks.map(initUnit)};
}

function beginCombat(){
  // move player's remaining to bench
  const bench = G.player.hand.splice(0).map(initUnit);
  G.player.formation.bench = bench;

  $("#formation").classList.add("hidden");
  $("#combat").classList.remove("hidden");
  G.phase="combat";
  G.current="player";
  G.player.acted = {primary:false,secondary:false,support:false};
  G.ai.acted = {primary:false,secondary:false,support:false};
  G.player.swaps=0; G.ai.swaps=0;
  log("⚔️ Combat begins! Your turn.");
  updateTurnBanner();
  renderCombatBoards();
  enableActionButtons();
}

/* -------- Units / Status -------- */
function initUnit(card){
  if(!card) return null;
  return {
    ...clone(card),
    curHP: card.hp, curEN: card.energy,
    exhausted:false,
    status:{stunned:0,rooted:0,weakened:0,burned:0,poisoned:0,cover:0,anchor:(card.passive&&card.passive.kind==="anchor")?1:0},
    firstBonus:(card.passive&&card.passive.kind==="ambush")?(card.passive.value||0):0,
    shield:(card.passive&&card.passive.kind==="fortify")?(card.passive.value||0):0
  };
}

function unitAlive(u){ return u && u.curHP>0; }
function unitCanAct(u){ return unitAlive(u) && !u.exhausted && u.status.stunned<=0; }

/* -------- Rendering -------- */
function renderGarden(){
  const g = $("#garden"); g.innerHTML="";
  G.garden.forEach((c,i)=>{
    const el = renderCard(c);
    if(G.phase==="draft") { el.classList.add("selectable"); el.onclick = ()=> pickFromGarden(i); }
    g.appendChild(el);
  });
}

function renderHands(){
  const ph = $("#pHand"); if(ph){ ph.innerHTML=""; G.player.hand.forEach(c=> ph.appendChild(renderCard(c))); }
  const ah = $("#aHand"); if(ah){ ah.innerHTML=""; G.ai.hand.forEach(c=> { const el=renderCard(c); el.classList.add("ai"); ah.appendChild(el);}); }
}

function renderCard(c){
  const el = document.createElement("div"); el.className="card";
  el.innerHTML = `
    <div class="name">${c.name}</div>
    <div class="meta">${c.type} • ${c.rarity}</div>
    <div class="stats"><span>HP: ${c.hp}</span><span>ATK: ${c.atk}</span></div>
    <div class="stats"><span>EN: ${c.energy}</span></div>
    <div class="tags"><span class="tag">Passive: ${c.passive?c.passive.text:"—"}</span></div>
    <div class="tags"><span class="tag">Active: ${c.active? c.active.text+" (cost "+c.active.cost+")":"—"}</span></div>`;
  return el;
}
function renderMini(c){
  const el = document.createElement("div"); el.className="card";
  el.innerHTML = `<div class="name">${c.name}</div><div class="meta">${c.type}</div>`;
  return el;
}

function renderCombatBoards(){
  const PF = G.player.formation, AF = G.ai.formation;

  function fill(selector, u){
    const s = document.querySelector(`.slot[data-slot="${selector}"]`);
    s.innerHTML = "";
    if(!u){ s.textContent="(empty)"; return; }
    const el = document.createElement("div"); el.className="card";
    el.innerHTML = `
      <div class="name">${u.name}</div>
      <div class="meta">${u.type} • ${u.rarity}</div>
      <div class="stats"><span>HP: ${u.curHP}</span><span>ATK: ${u.atk}</span></div>
      <div class="stats"><span>EN: ${u.curEN}${u.exhausted?" (exhausted)":" "}</span></div>
      <div class="tags">
        ${u.status.stunned>0?'<span class="tag">Stunned</span>':""}
        ${u.status.rooted>0?'<span class="tag">Rooted</span>':""}
        ${u.status.weakened>0?'<span class="tag">Weakened</span>':""}
        ${u.status.burned>0?'<span class="tag">Burned</span>':""}
        ${u.status.poisoned>0?'<span class="tag">Poison '+u.status.poisoned+'</span>':""}
        ${u.status.cover>0?'<span class="tag">Cover -'+u.status.cover+'</span>':""}
        ${u.shield>0?'<span class="tag">Shield '+u.shield+'</span>':""}
      </div>`;
    s.appendChild(el);
  }

  fill("player-primary", PF.primary); fill("player-secondary", PF.secondary); fill("player-support", PF.support);
  fill("ai-primary", AF.primary); fill("ai-secondary", AF.secondary); fill("ai-support", AF.support);

  const pb = $("#player-bench"); pb.innerHTML="";
  PF.bench.forEach(u=>{ const el=document.createElement("div"); el.className="card"; el.innerHTML=`<div class="name">${u.name}</div><div class="stats"><span>HP:${u.curHP}</span></div>`; pb.appendChild(el); });
  const ab = $("#ai-bench"); ab.innerHTML="";
  AF.bench.forEach(u=>{ const el=document.createElement("div"); el.className="card ai"; el.innerHTML=`<div class="name">${u.name}</div><div class="stats"><span>HP:${u.curHP}</span></div>`; ab.appendChild(el); });
}

function renderLog(){ const el=$("#log"); el.innerHTML = G.log.slice(-100).map(x=>`<div>${x}</div>`).join(""); el.scrollTop=el.scrollHeight; }
function updateTurnBanner(){ $("#turn-banner").textContent = (G.current==="player"?"Your turn":"AI turn"); }
function renderAll(){ renderGarden(); renderHands(); renderCombatBoards(); }

/* -------- Actions / Combat -------- */
function enableActionButtons(){
  const F = G.player.formation;
  const canP = unitCanAct(F.primary) && F.primary.curEN>=1;
  const canS = unitCanAct(F.secondary) && F.secondary.curEN>=1;
  const canPa = unitCanAct(F.primary) && F.primary.active && F.primary.curEN>=F.primary.active.cost;
  const canSa = unitCanAct(F.secondary) && F.secondary.active && F.secondary.curEN>=F.secondary.active.cost;
  const canUa = unitCanAct(F.support) && F.support.active && F.support.curEN>=F.support.active.cost;

  const twoSwaps = G.player.swaps>=2;
  $("#btn-ap").disabled = !canP || twoSwaps;
  $("#btn-as").disabled = !canS || twoSwaps;
  $("#btn-pp").disabled = !canPa;
  $("#btn-ps").disabled = !canSa;
  $("#btn-pu").disabled = !canUa;
  $("#btn-swap").disabled = false;
  $("#btn-end").disabled = false;
  $("#status-line").textContent = "Act with Primary, Secondary, and Support (any order).";
}

function doAttack(side, role){
  const F = side==="player"? G.player.formation : G.ai.formation;
  const EF = side==="player"? G.ai.formation : G.player.formation;
  const atk = F[role]; if(!unitCanAct(atk) || atk.curEN<1) return;

  // target: attack opposing Primary by default
  const def = EF.primary && unitAlive(EF.primary) ? EF.primary :
              EF.secondary && unitAlive(EF.secondary) ? EF.secondary :
              EF.support;

  if(!def){ victory(side); return; }

  let dmg = atk.atk + (atk.firstBonus||0);
  if(ADV[atk.type]===def.type) dmg += 10; // type advantage on direct attack
  if(atk.firstBonus) atk.firstBonus=0;

  // swap penalty (half damage) if exactly one swap this turn from attacker side
  const swaps = side==="player"? G.player.swaps : G.ai.swaps;
  if(swaps===1 && (role==="primary" || role==="secondary")) dmg = Math.floor(dmg/2);

  // defender modifiers
  if(def.status.cover>0){ dmg = Math.max(0, dmg - def.status.cover); def.status.cover = 0; }
  if(def.shield>0){ const ab=Math.min(def.shield,dmg); def.shield-=ab; dmg-=ab; }
  if(def.passive&&def.passive.kind==="steadfast") dmg = Math.max(0, dmg - (def.passive.value||0));
  if(atk.status.weakened>0){ dmg = Math.max(0, dmg - 5); atk.status.weakened=0; }

  // burn makes next hit +10 received (unless Water w/ burnImmune)
  if(def.status.burned>0 && !(def.passive&&def.passive.kind==="burnImmune")){ dmg+=10; def.status.burned=0; }

  def.curHP -= Math.max(0,dmg);
  atk.curEN -= 1;
  log(`${label(side)} ${role} ${atk.name} hits ${label(side==="player"?"ai":"player")} Primary ${def.name} for ${dmg}.`);

  // reactive effects
  if(def.passive&&def.passive.kind==="thorns"){ atk.curHP -= (def.passive.value||0); log(`${def.name}'s Thorns deal ${(def.passive.value||0)} back.`); }
  if(atk.passive&&atk.passive.kind==="spores" && Math.random()<0.2){ def.status.weakened=1; log(`${def.name} is Weakened (-5 next).`); }

  postDamageCleanup();
  endIfExhaustedCheck(atk);

  renderCombatBoards(); enableActionButtons(); checkVictory();
}

function useActive(side, role){
  const F = side==="player"? G.player.formation : G.ai.formation;
  const EF = side==="player"? G.ai.formation : G.player.formation;
  const u = F[role]; if(!unitCanAct(u) || !u.active || u.curEN<u.active.cost) return;

  const a = u.active;
  const spend = ()=>{ u.curEN -= a.cost; endIfExhaustedCheck(u); };

  // simple target helpers
  const ally = (t)=> (t==="self"? u : F.primary||F.secondary||F.support);
  const enemyFront = ()=> EF.primary && unitAlive(EF.primary)? EF.primary : (EF.secondary&&unitAlive(EF.secondary)? EF.secondary : EF.support);

  switch(a.kind){
    case "heal":{
      const tgt = ally(a.target);
      if(!tgt) break;
      const v = a.value||0; tgt.curHP = Math.min(tgt.hp, tgt.curHP+v);
      log(`${u.name} heals ${tgt.name} for ${v}.`); spend(); break;
    }
    case "energize":{
      const tgt = a.target==="ally"? (F.primary||F.secondary||F.support) : u;
      if(!tgt) break;
      const v = a.value||1; tgt.curEN += v;
      log(`${u.name} energizes ${tgt.name} +${v} EN.`); spend(); break;
    }
    case "stun":{
      const tgt = enemyFront(); if(!tgt) break;
      tgt.status.stunned = Math.max(tgt.status.stunned, (a.value||1));
      log(`${u.name} stuns ${tgt.name} for ${a.value||1} turn.`); spend(); break;
    }
    case "poison":{
      const tgt = enemyFront(); if(!tgt) break;
      tgt.status.poisoned += (a.value||1);
      log(`${u.name} poisons ${tgt.name} (${tgt.status.poisoned}).`); spend(); break;
    }
    case "burn":{
      const tgt = enemyFront(); if(!tgt) break;
      if(!(tgt.passive&&tgt.passive.kind==="burnImmune")) tgt.status.burned = 1;
      log(`${u.name} applies Burn to ${tgt.name}.`); spend(); break;
    }
    case "weaken":{
      const tgt = enemyFront(); if(!tgt) break;
      tgt.status.weakened = 1;
      log(`${u.name} weakens ${tgt.name} (-5 next).`); spend(); break;
    }
    case "cover":{
      const tgt = ally("ally"); if(!tgt) break;
      tgt.status.cover = Math.max(tgt.status.cover, a.value||5);
      log(`${u.name} covers ${tgt.name} (-${tgt.status.cover} next hit).`); spend(); break;
    }
    case "root":{
      const tgt = enemyFront(); if(!tgt) break;
      tgt.status.rooted = Math.max(tgt.status.rooted, a.value||1);
      log(`${u.name} roots ${tgt.name}.`); spend(); break;
    }
    case "drain":{
      const tgt = EF.primary; if(!tgt) break;
      const v = Math.min(tgt.curEN, (a.value||1));
      tgt.curEN -= v; u.curEN += v; // transfer to user
      log(`${u.name} drains ${v} EN from ${tgt.name}.`); spend(); break;
    }
    case "seed":{
      // add a 10/10 seedling to bench with same type, 1 EN
      const seed = {name:"Seedling", type:u.type, rarity:"Seed", energy:1, hp:10, atk:10,
                    passive:null, active:null};
      const su = initUnit(seed);
      F.bench.push(su);
      log(`${u.name} seeds a 10/10 ${u.type} on your bench.`); spend(); break;
    }
  }

  renderCombatBoards(); enableActionButtons(); checkVictory();
}

function startSwapFlow(){
  // very simple: swap your Secondary and Support if allowed, or Primary<->Secondary if Support anchored etc.
  // Real UI would let you pick; this keeps it one-button for mobile.
  const F = G.player.formation;
  if(F.support && F.support.status.anchor){ log("Support is anchored; trying Primary/Secondary."); }
  if(F.primary && F.primary.status.anchor && F.secondary && F.secondary.status.anchor){ log("Anchored — cannot swap."); return; }

  // try swap primary<->secondary first if not anchored
  if(F.primary && F.secondary && !F.primary.status.anchor && !F.secondary.status.anchor){
    [F.primary, F.secondary] = [F.secondary, F.primary];
    G.player.swaps++;
    log("You swapped Primary and Secondary.");
  } else if (F.secondary && F.support && !F.support.status.anchor){
    [F.secondary, F.support] = [F.support, F.secondary];
    G.player.swaps++;
    log("You swapped Secondary and Support.");
  } else {
    log("No valid swap available.");
    return;
  }

  // Swapped-in bench units enter with full EN (handled when moved from bench in replacements)
  renderCombatBoards(); enableActionButtons();
}

function endTurn(){
  // Exhaustion management: if any unit reached 0 EN this turn, they become exhausted and skip next turn;
  // at end of their skip, they refill to full.
  applyEndOfTurnEffects("player");
  G.current = "ai"; updateTurnBanner();
  renderCombatBoards(); enableActionButtons();
  setTimeout(aiTurn, 300); // quick handoff
}

function applyEndOfTurnEffects(side){
  const F = side==="player"? G.player.formation : G.ai.formation;

  // Regen & Vitalize passives
  if(unitAlive(F.support) && F.support.passive && F.support.passive.kind==="vitalize"){
    const target = F.primary && unitAlive(F.primary)? F.primary : F.secondary;
    if(target){ target.curEN += (F.support.passive.value||1); log(`${label(side)} Support vitalizes ${target.name} +${F.support.passive.value||1} EN.`); }
  }
  if(unitAlive(F.primary) && F.primary.passive && F.primary.passive.kind==="regen"){
    F.primary.curHP = Math.min(F.primary.hp, F.primary.curHP + (F.primary.passive.value||0));
    log(`${label(side)} Primary regenerates ${(F.primary.passive.value||0)} HP.`);
  }

  // Poison damage tick
  ["primary","secondary","support"].forEach(r=>{
    const u = F[r]; if(!unitAlive(u)) return;
    if(u.status.poisoned>0){
      u.curHP -= 5;
      u.status.poisoned--;
      log(`${u.name} takes 5 poison damage (${u.status.poisoned} left).`);
    }
  });

  // Exhaustion: if a unit had 0 EN at start of this turn (exhausted), it refills now and is no longer exhausted
  ["primary","secondary","support"].forEach(r=>{
    const u = F[r]; if(!u) return;
    if(u.exhausted){
      u.curEN = u.energy;
      u.exhausted = false;
      log(`${u.name} refreshes to full energy.`);
    }
    if(u.curEN<=0 && !u.exhausted){
      u.exhausted = true; // will skip next turn; refills at next end
    }
  });

  // Reset swap count
  if(side==="player") G.player.swaps=0; else G.ai.swaps=0;

  // Replace dead frontliners
  handleReplacements(side);
  checkVictory();
}

function handleReplacements(side){
  const F = side==="player"? G.player.formation : G.ai.formation;
  // replacement order: Secondary -> Primary; Support -> Secondary; Bench -> Support
  if(!unitAlive(F.primary)){
    if(unitAlive(F.secondary)){ F.primary = F.secondary; F.secondary = null; }
    else if(unitAlive(F.support)){ F.primary = F.support; F.support = null; }
  }
  if(!unitAlive(F.secondary) && unitAlive(F.support)){ F.secondary = F.support; F.support = null; }
  if(!unitAlive(F.support) && F.bench.length>0){
    const inU = F.bench.shift();
    // entering from bench: full energy
    inU.curEN = inU.energy; inU.exhausted=false;
    F.support = inU;
  }
}

function endIfExhaustedCheck(u){
  if(u.curEN<=0){ u.exhausted=true; }
}

function label(side){ return side==="player"?"You":"AI"; }

function postDamageCleanup(){
  // (placeholder for future combined effects)
}

function checkVictory(){
  const P = G.player.formation, A = G.ai.formation;
  const pAlive = [P.primary,P.secondary,P.support,...P.bench].some(unitAlive);
  const aAlive = [A.primary,A.secondary,A.support,...A.bench].some(unitAlive);
  if(!pAlive || !aAlive){
    const winner = pAlive? "You win! 🌟" : "AI wins! 🤖";
    log("Game over — " + winner);
    $("#status-line").textContent = winner;
    disableAllActions();
  }
}

function disableAllActions(){
  ["#btn-ap","#btn-as","#btn-pp","#btn-ps","#btn-pu","#btn-swap","#btn-end"].forEach(id=> $(id).disabled = true);
}

/* -------- AI Turn -------- */
function aiTurn(){
  if(G.phase!=="combat") return;
  const F = G.ai.formation, E = G.player.formation;

  // Basic AI plan per role:
  // 1) If support can heal an injured ally or energize a key ally, use it.
  // 2) If primary has energy, attack; else active if useful.
  // 3) If secondary has energy, attack; else active if useful.
  // 4) Occasionally swap to bring higher HP/ATK forward (if not anchored).

  // Support active
  if(unitCanAct(F.support) && F.support.active && F.support.curEN>=F.support.active.cost){
    const a = F.support.active;
    let did=false;
    if(a.kind==="heal"){
      const target = [F.primary,F.secondary,F.support].filter(x=>x).sort((a,b)=>(a.curHP/a.hp)-(b.curHP/b.hp))[0];
      if(target && target.curHP<target.hp){
        F.support.curEN -= a.cost; target.curHP = Math.min(target.hp, target.curHP + (a.value||6));
        log(`🤖 ${F.support.name} heals ${target.name}.`); did=true;
      }
    } else if (a.kind==="energize"){
      const target = F.primary && unitAlive(F.primary)? F.primary : F.secondary;
      if(target){ F.support.curEN -= a.cost; target.curEN += (a.value||1); log(`🤖 ${F.support.name} energizes ${target.name}.`); did=true; }
    } else if (["stun","poison","burn","weaken","cover","root","drain","seed"].includes(a.kind)){
      // just use on default target/ally
      useActive("ai","support"); did=true;
    }
    if(did) endIfExhaustedCheck(F.support);
  }

  // Maybe swap if primary is very low and secondary is healthier & not anchored
  if(unitAlive(F.secondary) && unitAlive(F.primary) && !F.primary.status.anchor && !F.secondary.status.anchor){
    if(F.primary.curHP < F.secondary.curHP/2 && G.ai.swaps<2){
      [F.primary,F.secondary] = [F.secondary,F.primary];
      G.ai.swaps++; log("🤖 AI swaps Primary and Secondary.");
    }
  }

  // Primary action: attack preferred
  if(unitCanAct(F.primary) && F.primary.curEN>=1){ doAttack("ai","primary"); }
  else if(unitCanAct(F.primary) && F.primary.active && F.primary.curEN>=F.primary.active.cost){ useActive("ai","primary"); }

  // Secondary action
  if(unitCanAct(F.secondary) && F.secondary.curEN>=1){ doAttack("ai","secondary"); }
  else if(unitCanAct(F.secondary) && F.secondary.active && F.secondary.curEN>=F.secondary.active.cost){ useActive("ai","secondary"); }

  // End AI turn
  applyEndOfTurnEffects("ai");
  G.current="player"; updateTurnBanner();
  renderCombatBoards(); enableActionButtons(); checkVictory();
}

/* -------- Helpers -------- */
function renderArrangeToBenches(){
  $("#player-bench-setup").innerHTML="";
  G.player.hand.forEach(c=> $("#player-bench-setup").appendChild(renderMini(c)));
}

function renderArrangeSlots(){
  $$(".slot[data-slot^='player-']").forEach(s=> s.innerHTML="(empty)");
}

function renderLogOnce(){ renderLog(); }

function renderAllDraft(){ renderGarden(); renderHands(); }

function renderAllCombat(){ renderCombatBoards(); enableActionButtons(); }

function renderAll(){ renderGarden(); renderHands(); renderCombatBoards(); }

/* -------- Start ---------- */
newGame();
</script>
</body>
</html>
