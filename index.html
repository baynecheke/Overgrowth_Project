<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Overgrowth</title>
<style>
body { margin:0; font-family:'Segoe UI',sans-serif; background:#e8f5e9; display:flex; justify-content:center; align-items:center; min-height:100vh; overflow-x:hidden;}
#loadingScreen { position:absolute; width:100%; height:100%; display:flex; justify-content:center; align-items:center; flex-direction:column;
    background:linear-gradient(45deg, #4caf50, #81c784, #a5d6a7);
    color:white; font-size:2em; text-shadow:2px 2px 6px black; z-index:10;
}
#progressBar { width:80%; height:20px; background:#ddd; border-radius:10px; margin-top:20px; overflow:hidden;}
#progressFill { width:0%; height:100%; background:#4caf50;}
#flowerCanvas { width:150px; height:150px; margin:20px;}
#gameContainer { display:none; flex-direction:column; align-items:center; width:100%; max-width:1200px; }
.board { display:flex; justify-content:space-between; width:100%; margin-top:20px; }
.playerBoard { display:flex; flex-direction:column; align-items:center; }
.cardsRow { display:flex; margin:5px 0; }
.card { width:120px; height:180px; background:white; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.3); margin:5px; position:relative; display:flex; flex-direction:column; justify-content:flex-start; align-items:center; padding:5px; font-size:12px; cursor:pointer; transition:transform 0.3s; }
.card:hover { transform: scale(1.05); }
.stats { text-align:center; font-size:12px; margin-top:5px; }
.status { font-size:10px; color:#333; margin-top:2px; text-align:center;}
.hpBar { height:10px; width:100%; background:#ddd; border-radius:5px; overflow:hidden; margin-top:3px; }
.hpFill { height:100%; background:#f44336; transition:width 0.5s; }
.energyBar { height:6px; width:100%; background:#ddd; border-radius:3px; overflow:hidden; margin-top:2px; }
.energyFill { height:100%; background:#ffeb3b; transition:width 0.5s; }
.highlight { box-shadow:0 0 15px yellow;}
#actions { margin-top:10px; display:flex; flex-wrap:wrap; justify-content:center; }
button { margin:5px; padding:8px 15px; font-size:14px; border-radius:5px; border:none; background:#4caf50; color:white; cursor:pointer; }
button:hover { background:#45a049; }
#combatLog { max-height:200px; overflow-y:auto; width:90%; background:#fff; padding:10px; margin-top:10px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.2); font-size:14px; }
.damagePop { position:absolute; color:red; font-weight:bold; animation:pop 0.8s ease-out forwards; }
.healPop { position:absolute; color:green; font-weight:bold; animation:pop 0.8s ease-out forwards; }
@keyframes pop { 0% {opacity:1; transform:translateY(0);} 100% {opacity:0; transform:translateY(-30px);} }
</style>
</head>
<body>
<div id="loadingScreen">
  <div>Loading Overgrowth...</div>
  <canvas id="flowerCanvas" width="150" height="150"></canvas>
  <div id="progressBar"><div id="progressFill"></div></div>
</div>

<div id="gameContainer">
<h1>Overgrowth</h1>
<div id="garden" style="display:flex; flex-wrap:wrap; justify-content:center;"></div>
<button id="finishDraft">Finish Draft</button>
<div class="board">
<div class="playerBoard" id="playerBoard">
<h2>You</h2>
<div class="cardsRow" id="playerActive"></div>
<div class="cardsRow" id="playerBench"></div>
</div>
<div class="playerBoard" id="aiBoard">
<h2>AI</h2>
<div class="cardsRow" id="aiActive"></div>
<div class="cardsRow" id="aiBench"></div>
</div>
</div>
<div id="actions"></div>
<div id="combatLog"></div>
</div>

<script>
// Types and advantage
const types=['Sun','Water','Thorn','Fungal','Normal','Nocturnal'];
const typeAdvantage={'Nocturnal':'Fungal','Fungal':'Normal','Normal':'Thorn','Thorn':'Water','Water':'Sun','Sun':'Nocturnal'};

// Game variables
let gardenDeck=[], playerDeck=[], aiDeck=[], combatLog=[];
let playerFormation={}, aiFormation={}, currentPlayer=null;

// Logging
function log(msg, type='normal'){ 
    const logEl=document.getElementById('combatLog'); 
    let color = type==='damage'?'red': type==='heal'?'green':'black';
    combatLog.push(`<span style="color:${color}">${msg}</span>`); 
    logEl.innerHTML=combatLog.join('<br>'); 
    logEl.scrollTop=logEl.scrollHeight; 
}

// Card drawing
function drawCardArt(name,type){
    const canvas=document.createElement('canvas');
    canvas.width=120; canvas.height=180;
    const ctx=canvas.getContext('2d');
    const colors = {Sun:'#ffe082',Water:'#64b5f6',Thorn:'#81c784',Fungal:'#ba68c8',Normal:'#e0e0e0',Nocturnal:'#455a64'};
    ctx.fillStyle = colors[type]||'#fff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle='#333'; ctx.lineWidth=3; ctx.strokeRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#000'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.fillText(name,canvas.width/2,20);
    ctx.font='12px sans-serif'; ctx.fillText(type,canvas.width/2,40);
    return canvas;
}

// Card creation
function createCard(name){
    const type=types[Math.floor(Math.random()*types.length)];
    const hp=Math.floor(Math.random()*20)+10;
    const atk=Math.floor(Math.random()*10)+5;
    const energy=Math.floor(Math.random()*3)+1;
    const keywords = ['Quick','Poison','Regenerate','Shield'];
    const passive = (self, ally, enemy) => { if(self.hp<self.maxHp/2) self.atk+=2; };
    const active = (self, ally, enemy) => {
        if(self.energy>=1){
            let target=ally.find(c=>c&&c.hp<c.maxHp);
            if(target){ target.hp=Math.min(target.maxHp,target.hp+5); self.energy--; showHeal(target,'+5'); log(`${self.name} heals ${target.name} 5 HP.`,'heal'); }
        }
    };
    const illustration=drawCardArt(name,type);
    return {name,type,hp,maxHp:hp,atk,baseAtk:atk,energy,maxEnergy:energy,exhausted:false,statuses:[],keywords,passive,active,illustration};
}

// Initialize drafting
function initGame(){
    const garden=document.getElementById('garden'); garden.innerHTML='';
    const cardNames=['Rose','Cactus','Mushroom','Sunflower','Nightshade','Fern','Lily','Ivy','Daisy','Orchid','Bamboo','Tulip'];
    gardenDeck=cardNames.map(name=>createCard(name));
    gardenDeck.forEach(card=>{
        const el=createCardElement(card,false);
        el.onclick=()=>{ 
            if(playerDeck.length<3){ 
                playerDeck.push(card); 
                el.classList.add('highlight'); 
            }
        };
        garden.appendChild(el);
    });
    aiDeck=aiDraft(3,gardenDeck);
}

// AI draft
function aiDraft(n,cards){ 
    let selected=[]; 
    while(selected.length<n){ 
        let best=cards[Math.floor(Math.random()*cards.length)]; 
        if(!selected.includes(best)) selected.push(best);
    } 
    return selected; 
}

// Card element with HP & energy bars
function createCardElement(card,showStats=true){
    const el=document.createElement('div'); el.classList.add('card');
    el.appendChild(card.illustration);

    if(showStats){
        const stats=document.createElement('div'); stats.className='stats';
        stats.innerHTML=`ATK: ${card.atk} | HP: <span class="hpVal">${card.hp}</span>/${card.maxHp} | Energy: <span class="energyVal">${card.energy}</span>`;
        el.appendChild(stats);

        const hpBar=document.createElement('div'); hpBar.className='hpBar';
        const hpFill=document.createElement('div'); hpFill.className='hpFill'; hpFill.style.width=(card.hp/card.maxHp*100)+'%';
        hpBar.appendChild(hpFill);
        el.appendChild(hpBar);

        const energyBar=document.createElement('div'); energyBar.className='energyBar';
        const energyFill=document.createElement('div'); energyFill.className='energyFill'; energyFill.style.width=(card.energy/card.maxEnergy*100)+'%';
        energyBar.appendChild(energyFill);
        el.appendChild(energyBar);

        const kw=document.createElement('div'); kw.className='status'; kw.textContent=card.keywords.join(', ');
        el.appendChild(kw);
    }

    return el;
}

// Finish draft
document.getElementById('finishDraft').onclick=()=>{
    if(playerDeck.length!==3){alert('Pick 3 cards'); return;}
    document.getElementById('garden').style.display='none';
    document.getElementById('finishDraft').style.display='none';
    document.getElementById('loadingScreen').style.display='none';
    startCombat();
}

// Combat setup
function startCombat(){
    playerFormation.active=playerDeck; playerFormation.bench=[];
    aiFormation.active=aiDeck; aiFormation.bench=[];
    log("Combat begins!");
    currentPlayer='player';
    updateBoard();
    promptPlayerAction();
}

// Update board
function updateBoard(){
    function render(containerId,cards){
        const container=document.getElementById(containerId); container.innerHTML='';
        cards.forEach(c=>container.appendChild(createCardElement(c)));
    }
    render('playerActive',playerFormation.active);
    render('aiActive',aiFormation.active);
}

// Animate card actions
function animateCardAction(cardEl, dmg=0, heal=0, energyChange=0){
    const hpFill = cardEl.querySelector('.hpFill');
    const energyFill = cardEl.querySelector('.energyFill');
    const hpVal = cardEl.querySelector('.hpVal');
    const energyVal = cardEl.querySelector('.energyVal');

    if(dmg>0){
        let newHP = Math.max(card.hp,0);
        hpFill.style.width = (newHP/card.maxHp*100)+'%';
        if(hpVal) hpVal.textContent = newHP;
        cardEl.style.transform='translateX(5px)';
        setTimeout(()=>cardEl.style.transform='translateX(0)',100);
    }
    if(heal>0){
        let newHP = Math.min(card.hp, card.maxHp);
        hpFill.style.width = (newHP/card.maxHp*100)+'%';
        if(hpVal) hpVal.textContent = newHP;
        cardEl.style.transform='translateY(-5px)';
        setTimeout(()=>cardEl.style.transform='translateY(0)',100);
    }
    if(energyChange!==0){
        let newEnergy = Math.max(0, card.energy);
        energyFill.style.width = (newEnergy/card.maxEnergy*100)+'%';
        if(energyVal) energyVal.textContent = newEnergy;
    }
}

// Find card element by illustration
function findCardElement(card){
    const boards = ['playerActive','aiActive'];
    for(let b of boards){
        const container = document.getElementById(b);
        for(let el of container.children){
            const canvas = el.querySelector('canvas');
            if(canvas && canvas === card.illustration) return el;
        }
    }
    return null;
}

// Popups
function showDamage(card, amount){
    const dmg = document.createElement('div'); 
    dmg.classList.add('damagePop'); 
    dmg.textContent = amount; 
    document.body.appendChild(dmg); 
    const cardEl = findCardElement(card);
    if(cardEl) animateCardAction(cardEl, amount,0,0);
    setTimeout(()=>document.body.removeChild(dmg),800);
}

function showHeal(card, amount){
    const heal = document.createElement('div'); 
    heal.classList.add('healPop'); 
    heal.textContent = amount; 
    document.body.appendChild(heal); 
    const cardEl = findCardElement(card);
    if(cardEl) animateCardAction(cardEl,0,amount,0);
    setTimeout(()=>document.body.removeChild(heal),800);
}

// Player action
function promptPlayerAction(){
    if(playerFormation.active.length===0||aiFormation.active.length===0){ checkVictory(); return;}
    const actionsDiv=document.getElementById('actions'); actionsDiv.innerHTML='';
    playerFormation.active.forEach((card,i)=>{
        if(card.exhausted) return;
        const btn=document.createElement('button'); btn.textContent=`Use ${card.name}`; btn.onclick=()=>{ chooseCardAction(card); };
        actionsDiv.appendChild(btn);
    });
}

// Choose action
function chooseCardAction(card){
    const actionsDiv=document.getElementById('actions'); actionsDiv.innerHTML='';
    const attackBtn=document.createElement('button'); attackBtn.textContent='Attack'; attackBtn.onclick=()=>{ chooseTarget(card); };
    const abilityBtn=document.createElement('button'); abilityBtn.textContent='Use Ability'; abilityBtn.onclick=()=>{
        card.active(card,playerFormation.active,aiFormation.active);
        card.energy--; if(card.energy<=0){ card.exhausted=true; card.energy=0;}
        updateBoard(); setTimeout(aiTurn,500);
    };
    const passBtn=document.createElement('button'); passBtn.textContent='Pass'; passBtn.onclick=()=>{ card.exhausted=true; setTimeout(aiTurn,500); }
    actionsDiv.appendChild(attackBtn); actionsDiv.appendChild(abilityBtn); actionsDiv.appendChild(passBtn);
}

// Choose target
function chooseTarget(attacker){
    const actionsDiv=document.getElementById('actions'); actionsDiv.innerHTML='Select a target:';
    aiFormation.active.forEach(target=>{
        const btn=document.createElement('button'); btn.textContent=target.name; btn.onclick=()=>{
            let dmg=attacker.atk; if(typeAdvantage[attacker.type]===target.type) dmg+=10;
            target.hp-=dmg; showDamage(target,dmg); log(`${attacker.name} attacks ${target.name} for ${dmg}`,'damage');
            if(target.hp<=0){ aiFormation.active=aiFormation.active.filter(c=>c!==target); log(`${target.name} defeated!`);}
            attacker.energy--; if(attacker.energy<=0){ attacker.exhausted=true; attacker.energy=0;}
            updateBoard(); setTimeout(aiTurn,500);
        };
        actionsDiv.appendChild(btn);
    });
}

// AI turn
function aiTurn(){
    if(aiFormation.active.length===0||playerFormation.active.length===0){ checkVictory(); return;}
    let card=aiFormation.active.find(c=>!c.exhausted);
    if(!card){ 
        playerFormation.active.forEach(c=>c.exhausted=false); 
        aiFormation.active.forEach(c=>c.exhausted=false); 
        promptPlayerAction(); 
        return;
    }
    let target=playerFormation.active.reduce((a,b)=>(b.hp<a.hp?b:a),playerFormation.active[0]);
    let dmg=card.atk; if(typeAdvantage[card.type]===target.type) dmg+=10;
    target.hp-=dmg; showDamage(target,dmg); log(`AI's ${card.name} attacks ${target.name} for ${dmg}`,'damage');
    const targetEl=findCardElement(target);
    if(targetEl){ targetEl.style.transform='translateX(5px)'; setTimeout(()=>targetEl.style.transform='translateX(0)',100);}
    if(target.hp<=0){ playerFormation.active=playerFormation.active.filter(c=>c!==target); log(`${target.name} defeated!`);}
    card.energy--; if(card.energy<=0){ card.exhausted=true; card.energy=0;}
    updateBoard(); setTimeout(promptPlayerAction,500);
}

// Check victory
function checkVictory(){
    if(playerFormation.active.length===0){ alert('AI Wins!'); log('AI Wins!'); return true;}
    if(aiFormation.active.length===0){ alert('You Win!'); log('You Win!'); return true;}
}

// Flower animation on loading
let progress=0;
let progressFlower=0;
const flowerCanvas=document.getElementById('flowerCanvas');
const ctx=flowerCanvas.getContext('2d');

function drawFlower(progress){
    ctx.clearRect(0,0,flowerCanvas.width,flowerCanvas.height);
    ctx.save();
    ctx.translate(flowerCanvas.width/2, flowerCanvas.height);
    let stemHeight=100*progress;
    ctx.strokeStyle='#2e7d32';
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-stemHeight);
    ctx.stroke();
    if(progress>0.6){
        let petalCount=6;
        ctx.fillStyle='#f44336';
        let petalSize=10*(progress-0.6)/0.4;
        for(let i=0;i<petalCount;i++){
            let angle=(i*Math.PI*2)/petalCount;
            ctx.beginPath();
            ctx.ellipse(Math.cos(angle)*20, -stemHeight+Math.sin(angle)*20, petalSize, petalSize, 0,0,Math.PI*2);
            ctx.fill();
        }
    }
    ctx.restore();
}

let loadInterval=setInterval(()=>{
  progress+=0.01;
  if(progress>1) progress=1;
  drawFlower(progress);
  document.getElementById('progressFill').style.width=(progress*100)+'%';
  if(progress>=1){ clearInterval(loadInterval); setTimeout(()=>{ document.getElementById('loadingScreen').style.display='none'; document.getElementById('gameContainer').style.display='flex'; initGame(); },500);}
},50);

</script>
</body>
</html>

