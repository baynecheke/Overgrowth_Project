
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Overgrowth - Full Game (AI + Difficulty)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@600&display=swap');
  :root{
    --bg1:#dff5d9; --bg2:#7abd74; --panel:#f0f9f0dd; --text:#18491d;
    --green:#2e7d32; --muted:#8fbc8f; --card:#a3d08d;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:'Montserrat',sans-serif;color:var(--text);
    background:linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%);user-select:none}
  #container{max-width:900px;margin:14px auto;background:var(--panel);
    border-radius:12px;padding:16px;box-shadow:0 12px 30px rgba(42,111,26,0.25)}
  h1,h2{margin:0 0 10px;text-align:center}
  #phase{font-weight:800;text-align:center;margin-bottom:10px;color:#164916}
  .row{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
  .cards-row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;min-height:140px}
  .card{width:130px;padding:10px;background:var(--card);border-radius:10px;
    box-shadow:0 0 6px #529534;cursor:pointer;transition:transform .18s,box-shadow .18s;position:relative}
  .card:hover{transform:scale(1.06);box-shadow:0 0 14px #4a8c32}
  .card .name{font-weight:800;text-align:center}
  .card .type{font-style:italic;text-align:center;color:var(--green);font-weight:700}
  .card .stats{font-size:0.82rem;margin-top:6px;line-height:1.15}
  .card.selected{outline:3px solid #276626;transform:scale(1.08)}
  .slot{width:140px;height:150px;border-radius:10px;background:#b9dba0;display:flex;
    flex-direction:column;align-items:center;justify-content:center;font-weight:800;color:#264f26;cursor:pointer;position:relative}
  .slot.empty{opacity:.6;font-style:italic}
  .slot .meta{font-size:0.8rem;font-weight:600;margin-top:6px}
  .marker{position:absolute;top:6px;right:6px;background:rgba(0,0,0,0.08);
    border-radius:6px;padding:2px 6px;font-size:0.75rem;font-weight:800}
  .marker.stunned{background:#ffd6d6;color:#8b1e1e}
  .marker.exhausted{background:#fff0c2;color:#8b5b00}
  .energy-bar{width:100%;height:8px;background:#d6f0d6;border-radius:6px;overflow:hidden;margin-top:6px}
  .energy-fill{height:100%;background:#2e7d32;width:0%}
  #controls{display:flex;gap:10px;justify-content:center;margin-top:12px}
  button{background:var(--green);color:white;border:none;padding:10px 14px;border-radius:10px;
    font-weight:800;cursor:pointer}
  button:disabled{background:var(--muted);cursor:not-allowed}
  #log{background:#f9f9f9;border-radius:8px;padding:10px;height:160px;overflow:auto;border:2px solid #a1d07a;white-space:pre-wrap;color:#164916;margin-top:12px}
  #difficulty-screen{display:flex;flex-direction:column;align-items:center;gap:10px;margin:12px 0}
  .difficulty-btn{padding:12px 18px;border-radius:12px;background:#2e7d32;color:white;font-weight:900;cursor:pointer}
  .difficulty-row{display:flex;gap:12px}
  .player-highlight{box-shadow:0 0 18px #4a9132}
  small.note{display:block;text-align:center;color:#355b30;margin-top:6px}
  @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}50%{transform:translateX(5px)}75%{transform:translateX(-5px)}}
  .shake{animation:shake .4s ease}
</style>
</head>
<body>
  <div id="container">
    <h1>Overgrowth â€” Plants Clash</h1>
    <div id="phase">Pick a difficulty to start</div>

    <div id="difficulty-screen">
      <div class="difficulty-row">
        <button class="difficulty-btn" data-diff="easy">Easy</button>
        <button class="difficulty-btn" data-diff="normal">Normal</button>
        <button class="difficulty-btn" data-diff="hard">Hard</button>
      </div>
      <small class="note">Easy: AI plays randomly. Normal: AI uses basics. Hard: AI is aggressive and energy-aware.</small>
      <div style="margin-top:10px;"><button id="two-player-btn">Two Player (Local)</button></div>
    </div>

    <div id="start-controls" style="display:none;text-align:center;margin-bottom:10px">
      <button id="start-btn">Start Draft</button>
      <button id="restart-btn" style="margin-left:8px;display:none">Restart</button>
    </div>

    <div id="garden-section" style="display:none">
      <h2>Garden (Draft)</h2>
      <div id="garden" class="cards-row"></div>
    </div>

    <div id="hand-section" style="display:none">
      <h2>Your Hand</h2>
      <div id="hand" class="cards-row"></div>
    </div>

    <div id="formation-section" style="display:none">
      <h2>Set Formation</h2>
      <p style="text-align:center;color:#2a5b2a;font-weight:800">Tap a card from your hand, then tap a formation slot</p>
      <div id="formation-slots" class="row" style="margin-top:8px">
        <div class="slot empty" data-slot="primary">Primary</div>
        <div class="slot empty" data-slot="secondary">Secondary</div>
        <div class="slot empty" data-slot="support">Support</div>
      </div>
      <div style="text-align:center;margin-top:8px">
        <button id="confirm-formation" disabled>Confirm Formation</button>
      </div>
    </div>

    <div id="combat-section" style="display:none">
      <h2>Combat Phase</h2>
      <div id="combat-info" style="text-align:center;margin-bottom:8px"></div>

      <h3>Your Formation</h3>
      <div id="player-formation" class="cards-row"></div>

      <h3>Opponent Formation</h3>
      <div id="opponent-formation" class="cards-row"></div>

      <div id="controls">
        <button id="attack-btn" disabled>Attack (1)</button>
        <button id="active-btn" disabled>Use Active</button>
        <button id="end-turn-btn" disabled>End Turn</button>
      </div>
    </div>

    <h2 style="margin-top:12px">Game Log</h2>
    <div id="log"></div>
  </div>

<script>
(() => {
  // ---- Card pool (extended, plant-themed) ----
  const BASE_CARDS = [
    {name:"Sunflower",type:"Sun",hp:30,atk:10,energyMax:3,passive:"Heal 2 HP start",activeCost:2,activeDesc:"Heal 5 HP self"},
    {name:"Water Lily",type:"Water",hp:25,atk:12,energyMax:3,passive:"Immune Burn",activeCost:2,activeDesc:"Energize self +2"},
    {name:"Thorn Bush",type:"Thorn",hp:40,atk:8,energyMax:2,passive:"Cover 3 damage ally",activeCost:1,activeDesc:"Deal 5 dmg to attacker"},
    {name:"Fungus",type:"Fungal",hp:20,atk:15,energyMax:3,passive:"Poison attacker 1 turn",activeCost:3,activeDesc:"Drain 2 energy enemy"},
    {name:"Nightshade",type:"Nocturnal",hp:28,atk:13,energyMax:3,passive:"+5 dmg at night",activeCost:2,activeDesc:"Stun enemy primary"},
    {name:"Grass",type:"Normal",hp:35,atk:9,energyMax:3,passive:"Chain +3 ATK if Nocturnal & Sun",activeCost:1,activeDesc:"Boost ally ATK +5 this turn"},
    {name:"Moss",type:"Fungal",hp:22,atk:14,energyMax:3,passive:"Weaken attacker",activeCost:2,activeDesc:"Poison enemy 2 turns"},
    {name:"Dewdrop",type:"Water",hp:27,atk:11,energyMax:3,passive:"Heal ally 1 HP",activeCost:1,activeDesc:"Energize ally +3"},
    {name:"Cactus",type:"Thorn",hp:42,atk:9,energyMax:2,passive:"Cover 5 damage",activeCost:2,activeDesc:"Reflect 3 damage"},
    {name:"Moonflower",type:"Nocturnal",hp:29,atk:14,energyMax:3,passive:"Regain 1 energy turn",activeCost:2,activeDesc:"Stun enemy support"},
    {name:"Sunberry",type:"Sun",hp:26,atk:13,energyMax:3,passive:"Heal 1 HP turn",activeCost:2,activeDesc:"Heal 7 HP ally"},
    {name:"Spikeweed",type:"Thorn",hp:38,atk:10,energyMax:2,passive:"Drain energy attacker",activeCost:2,activeDesc:"Deal 6 dmg"},
    {name:"Sporeling",type:"Fungal",hp:18,atk:16,energyMax:3,passive:"Chain poison allies",activeCost:3,activeDesc:"Seed 1"},
    {name:"Lunar Grass",type:"Nocturnal",hp:30,atk:12,energyMax:3,passive:"+10 dmg night",activeCost:2,activeDesc:"Boost self ATK +7"},
    {name:"Raindrop",type:"Water",hp:25,atk:14,energyMax:3,passive:"Immune burn",activeCost:1,activeDesc:"Energize self +4"},
    {name:"Thorn Vine",type:"Thorn",hp:39,atk:11,energyMax:2,passive:"Cover 4 dmg",activeCost:1,activeDesc:"Counter attack 5 dmg"},
    {name:"Normal Grass",type:"Normal",hp:34,atk:10,energyMax:3,passive:"Chain buff allies",activeCost:1,activeDesc:"Heal 4 HP"},
    {name:"Shadow Fungus",type:"Fungal",hp:21,atk:15,energyMax:3,passive:"Poison enemies",activeCost:3,activeDesc:"Drain 3 energy"},
    {name:"Solar Bloom",type:"Sun",hp:28,atk:12,energyMax:3,passive:"Heal self 2 HP",activeCost:2,activeDesc:"Heal ally 6 HP"},
    {name:"Night Vine",type:"Nocturnal",hp:27,atk:14,energyMax:3,passive:"Stun chance on attack",activeCost:2,activeDesc:"Stun enemy primary"},
    {name:"Frost Dew",type:"Water",hp:24,atk:13,energyMax:3,passive:"Slow enemy",activeCost:2,activeDesc:"Freeze attacker"},
    {name:"Spiny Bush",type:"Thorn",hp:41,atk:9,energyMax:2,passive:"Reflect damage",activeCost:1,activeDesc:"Counter attack 7 dmg"},
    {name:"Poison Moss",type:"Fungal",hp:19,atk:16,energyMax:3,passive:"Poison attacker",activeCost:3,activeDesc:"Seed 2"},
    {name:"Glowgrass",type:"Normal",hp:33,atk:11,energyMax:3,passive:"Chain buff",activeCost:1,activeDesc:"Boost ally ATK"},
    {name:"Dusk Flower",type:"Nocturnal",hp:28,atk:13,energyMax:3,passive:"+5 damage night",activeCost:2,activeDesc:"Stun enemy support"},
    {name:"Riverweed",type:"Water",hp:26,atk:12,energyMax:3,passive:"Heal ally 2 HP",activeCost:1,activeDesc:"Energize ally +2"},
    {name:"Briar Thorn",type:"Thorn",hp:40,atk:10,energyMax:2,passive:"Cover damage",activeCost:2,activeDesc:"Deal damage to attacker"},
    {name:"Seedling",type:"Normal",hp:10,atk:10,energyMax:1,passive:"No abilities",activeCost:0,activeDesc:""},
    // --- new cards (extra plant-themed) ---
    {name:"Thorned Bramble",type:"Thorn",hp:36,atk:12,energyMax:2,passive:"Return 2 dmg when hit",activeCost:2,activeDesc:"Deal 8 dmg"},
    {name:"Sunblossom Priestess",type:"Sun",hp:24,atk:8,energyMax:3,passive:"Boost allies +1 atk start",activeCost:2,activeDesc:"Heal all allies 4"},
    {name:"Venomous Pitcher",type:"Fungal",hp:23,atk:15,energyMax:3,passive:"Poison attackers",activeCost:3,activeDesc:"Poison enemy 3 turns"},
    {name:"Giant Puff Fungus",type:"Fungal",hp:45,atk:6,energyMax:2,passive:"Tanky",activeCost:2,activeDesc:"Seed 1"},
    {name:"Solar Sprout",type:"Sun",hp:22,atk:14,energyMax:3,passive:"Gain energy on heal",activeCost:1,activeDesc:"Energize self +2"},
    {name:"Ivy Snare",type:"Normal",hp:28,atk:9,energyMax:3,passive:"Slow attacker",activeCost:2,activeDesc:"Weaken enemy -3 ATK"},
    {name:"Mist Orchid",type:"Water",hp:26,atk:11,energyMax:3,passive:"Restore 1 HP passive",activeCost:2,activeDesc:"Heal ally 5"},
    {name:"Brimstone Moss",type:"Fungal",hp:20,atk:17,energyMax:3,passive:"Burn on hit",activeCost:3,activeDesc:"Drain 2 energy enemy"},
    {name:"Creeping Lantern",type:"Nocturnal",hp:30,atk:12,energyMax:3,passive:"Grant stealth night",activeCost:2,activeDesc:"Stun enemy support"},
  ];

  // type advantage mapping for flavor; not heavily used, but could be expanded
  const ADVANTAGE = { Nocturnal:"Fungal", Fungal:"Normal", Normal:"Thorn", Thorn:"Water", Water:"Sun", Sun:"Nocturnal" };

  // ---- Game state ----
  const state = {
    phase:'init',
    difficulty:'normal', // easy, normal, hard
    twoPlayer:false,
    garden:[],
    players:[
      {hand:[],formation:{primary:null,secondary:null,support:null},energy:{},hp:{},exhausted:{},statuses:{},formationSet:false},
      {hand:[],formation:{primary:null,secondary:null,support:null},energy:{},hp:{},exhausted:{},statuses:{},formationSet:false}
    ],
    draftCount:0,
    currentPlayer:0, // for drafting/formation: who's acting; for combat: active player
    tempSelectedCard:null,
    combatTurn:0,
    selectedAttacker:null, // object {card,slot}
    selectedTarget:null,
    aiThinkDelay:700
  };

  // ---- DOM ----
  const phaseEl = document.getElementById('phase');
  const gardenEl = document.getElementById('garden');
  const handEl = document.getElementById('hand');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');
  const formationSection = document.getElementById('formation-section');
  const formationSlots = document.querySelectorAll('.slot');
  const confirmFormationBtn = document.getElementById('confirm-formation');
  const playerFormationEl = document.getElementById('player-formation');
  const opponentFormationEl = document.getElementById('opponent-formation');
  const attackBtn = document.getElementById('attack-btn');
  const activeBtn = document.getElementById('active-btn');
  const endTurnBtn = document.getElementById('end-turn-btn');
  const logEl = document.getElementById('log');
  const combatInfoEl = document.getElementById('combat-info');
  const difficultyScreen = document.getElementById('difficulty-screen');
  const twoPlayerBtn = document.getElementById('two-player-btn');
  const startControls = document.getElementById('start-controls');
  const gardenSection = document.getElementById('garden-section');
  const handSection = document.getElementById('hand-section');
  const combatSection = document.getElementById('combat-section');

  // sounds stub (tiny silent wavs embedded earlier would be better; omitted to keep file small)
  function playSound(){}

  function log(msg){
    const now = new Date().toLocaleTimeString();
    logEl.textContent = `[${now}] ${msg}\n` + logEl.textContent;
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  // ---- Difficulty selection ----
  document.querySelectorAll('.difficulty-btn').forEach(b=>{
    b.addEventListener('click', ()=> {
      state.difficulty = b.dataset.diff;
      state.twoPlayer = false;
      difficultyScreen.style.display = 'none';
      startControls.style.display = 'block';
      document.getElementById('phase').textContent = `Difficulty: ${state.difficulty.toUpperCase()}. Click Start Draft to begin.`;
      startBtn.style.display = 'inline-block';
    });
  });
  twoPlayerBtn.addEventListener('click', ()=>{
    state.twoPlayer = true;
    difficultyScreen.style.display = 'none';
    startControls.style.display = 'block';
    phaseEl.textContent = 'Two-player local selected. Click Start Draft to begin.';
  });

  // ---- Start/Draft ----
  startBtn.addEventListener('click', ()=> startDraft());
  restartBtn.addEventListener('click', ()=> location.reload());

  function startDraft(){
    // reset
    state.phase = 'draft';
    state.draftCount = 0;
    state.currentPlayer = 0; // P1 starts picking
    state.players.forEach(p=>{
      p.hand=[]; p.formation={primary:null,secondary:null,support:null};
      p.energy={}; p.hp={}; p.exhausted={}; p.statuses={}; p.formationSet=false;
    });
    logEl.textContent = '';
    // create garden: draw randomly 6 cards per pick (reshuffle each pick)
    gardenSection.style.display = 'block';
    handSection.style.display = 'block';
    formationSection.style.display = 'none';
    combatSection.style.display = 'none';
    startBtn.style.display = 'none';
    restartBtn.style.display = 'inline-block';
    generateGardenChoices();
    renderGarden();
    renderHand();
    phaseEl.textContent = `Gardening Phase: Player ${state.currentPlayer+1} pick (${state.players[state.currentPlayer].hand.length}/3)`;
  }

  function generateGardenChoices(){
    // produce 6 random unique choices from extended pool
    const pool = BASE_CARDS.slice();
    shuffle(pool);
    state.garden = pool.slice(0,6).map(c=>({...c,id:Math.random().toString(36).slice(2)}));
  }

  function renderGarden(){
    gardenEl.innerHTML = '';
    state.garden.forEach(card =>{
      const el = createCardEl(card);
      el.addEventListener('click', ()=>{
        if(state.phase !== 'draft') return;
        if(state.players[state.currentPlayer].hand.length >= 3) return;
        // pick: give a fresh copy to player
        const copy = {...card,id:Math.random().toString(36).slice(2)};
        state.players[state.currentPlayer].hand.push(copy);
        // remove this garden choice
        state.garden = state.garden.filter(c => c.id !== card.id);
        state.draftCount++;
        // refill garden to 6 if needed (simulate new choices)
        if(state.garden.length < 2) generateGardenChoices(); // keep options varied
        renderGarden();
        renderHand();
        // switch player if two-player or alternate picks for single-player vs AI (AI picks automatically)
        if(state.twoPlayer){
          state.currentPlayer = (state.currentPlayer+1)%2;
          phaseEl.textContent = `Gardening Phase: Player ${state.currentPlayer+1} pick (${state.players[state.currentPlayer].hand.length}/3)`;
        } else {
          // if player just picked and AI needs to pick:
          if(state.players[0].hand.length < 3){
            state.currentPlayer = 1; // AI picks
            phaseEl.textContent = `Gardening Phase: AI picking...`;
            setTimeout(()=> aiDraftPick(), 400);
          } else if(state.players[1].hand.length < 3){
            // shouldn't happen here
          } else {
            // both have 3 -> move on
          }
        }
        // if both have 3 => formation
        if(state.players[0].hand.length===3 && state.players[1].hand.length===3){
          setTimeout(()=> startFormationSetup(), 350);
        }
      });
      gardenEl.appendChild(el);
    });
  }

  function renderHand(){
    handEl.innerHTML = '';
    const p = state.players[state.currentPlayer];
    p.hand.forEach(card=>{
      const el = createCardEl(card);
      // highlight selectable only in formation phase
      if(state.phase==='formation'){
        el.addEventListener('click', ()=>{
          if(state.tempSelectedCard && state.tempSelectedCard.id === card.id){
            state.tempSelectedCard = null;
            el.classList.remove('selected');
            return;
          }
          state.tempSelectedCard = card;
          Array.from(handEl.children).forEach(c=>c.classList.remove('selected'));
          el.classList.add('selected');
        });
      }
      handEl.appendChild(el);
    });
  }

  function createCardEl(card, small=false){
    const el = document.createElement('div');
    el.className = 'card';
    el.dataset.id = card.id;
    el.innerHTML = `<div class="name">${card.name}</div>
                    <div class="type">${card.type}</div>
                    <div class="stats">${small? '' : `HP: ${card.hp} &nbsp; ATK: ${card.atk}<br/>Energy: ${card.energyMax}<br/>Passive: ${card.passive || ''}<br/>Active: ${card.activeDesc} (Cost:${card.activeCost})`}</div>`;
    return el;
  }

  // ---- Formation setup (both players) ----
  function startFormationSetup(){
    state.phase = 'formation';
    state.currentPlayer = 0; // P1 sets first
    formationSection.style.display = 'block';
    handSection.style.display = 'block';
    gardenSection.style.display = 'none';
    combatSection.style.display = 'none';
    state.tempSelectedCard = null;
    renderHandFormation();
    updateFormationSlotsUI();
    phaseEl.textContent = `Formation Setup: Player ${state.currentPlayer+1}`;
    confirmFormationBtn.disabled = true;
    // If not two-player and AI should set automatically, after player1 finishes we will AI set
  }

  function renderHandFormation(){
    handEl.innerHTML = '';
    const p = state.players[state.currentPlayer];
    p.hand.forEach(card=>{
      const el = createCardEl(card);
      el.addEventListener('click', ()=>{
        if(state.phase !== 'formation') return;
        if(state.tempSelectedCard && state.tempSelectedCard.id === card.id){
          state.tempSelectedCard = null; el.classList.remove('selected'); return;
        }
        state.tempSelectedCard = card;
        Array.from(handEl.children).forEach(c=>c.classList.remove('selected'));
        el.classList.add('selected');
      });
      handEl.appendChild(el);
    });
    updateFormationSlotsUI();
  }

  formationSlots.forEach(slot=>{
    slot.addEventListener('click', ()=>{
      if(state.phase !== 'formation') return;
      if(!state.tempSelectedCard){
        slot.classList.add('shake'); setTimeout(()=>slot.classList.remove('shake'),400);
        return;
      }
      const s = slot.dataset.slot;
      if(state.players[state.currentPlayer].formation[s]){
        slot.classList.add('shake'); setTimeout(()=>slot.classList.remove('shake'),400); return;
      }
      // remove from hand and assign runtime fields
      const hand = state.players[state.currentPlayer].hand;
      const idx = hand.findIndex(c=>c.id === state.tempSelectedCard.id);
      if(idx === -1) return;
      const card = hand.splice(idx,1)[0];
      const runtime = {...card};
      runtime.currentHp = runtime.hp;
      runtime.currentEnergy = runtime.energyMax;
      runtime.id = runtime.id || Math.random().toString(36).slice(2);
      // store in formation
      state.players[state.currentPlayer].formation[s] = runtime;
      state.players[state.currentPlayer].energy[runtime.id] = runtime.currentEnergy;
      state.players[state.currentPlayer].hp[runtime.id] = runtime.currentHp;
      state.players[state.currentPlayer].exhausted[runtime.id] = false;
      state.players[state.currentPlayer].statuses[runtime.id] = {stunned:false,poison:0};
      state.tempSelectedCard = null;
      renderHandFormation();
      updateFormationSlotsUI();
      // enable confirm when all slots filled
      const f = state.players[state.currentPlayer].formation;
      confirmFormationBtn.disabled = !(f.primary && f.secondary && f.support);
    });
  });

  function updateFormationSlotsUI(){
    const p = state.players[state.currentPlayer];
    formationSlots.forEach(slot=>{
      const name = slot.dataset.slot;
      const card = p.formation[name];
      if(card){
        slot.classList.remove('empty');
        slot.innerHTML = `<div style="font-weight:900">${card.name}</div><div class="meta">HP:${card.currentHp} ATK:${card.atk}</div>
          <div class="energy-bar"><div class="energy-fill" style="width:${Math.round(100*(card.currentEnergy/card.energyMax)||0)}%"></div></div>`;
        // markers
        slot.querySelectorAll('.marker')?.forEach(m=>m.remove());
        if(p.statuses[card.id] && p.statuses[card.id].stunned) {
          const mk = document.createElement('div'); mk.className='marker stunned'; mk.textContent='STUNNED'; slot.appendChild(mk);
        }
      } else {
        slot.classList.add('empty');
        slot.innerHTML = name.charAt(0).toUpperCase()+name.slice(1);
        slot.querySelectorAll('.marker')?.forEach(m=>m.remove());
      }
    });
  }

  confirmFormationBtn.addEventListener('click', ()=>{
    state.players[state.currentPlayer].formationSet = true;
    log(`Player ${state.currentPlayer+1} confirmed formation.`);
    // switch to next
    if(state.twoPlayer){
      state.currentPlayer = 1 - state.currentPlayer;
      phaseEl.textContent = `Formation Setup: Player ${state.currentPlayer+1}`;
      state.tempSelectedCard = null;
      renderHandFormation();
      updateFormationSlotsUI();
      confirmFormationBtn.disabled = true;
      // But if both are set -> start combat
      if(state.players[0].formationSet && state.players[1].formationSet) startCombat();
    } else {
      // single-player: player sets then AI sets automatically
      if(state.currentPlayer === 0){
        state.currentPlayer = 1;
        phaseEl.textContent = 'Formation Setup: AI choosing formation...';
        // AI will auto-place cards
        setTimeout(()=> aiSetFormation(), 600);
      } else {
        // should not get here
      }
    }
  });

  // ---- Combat ----
  function startCombat(){
    state.phase = 'combat';
    formationSection.style.display = 'none';
    gardenSection.style.display = 'none';
    handSection.style.display = 'none';
    combatSection.style.display = 'block';
    state.currentPlayer = 0; // player starts
    state.combatTurn = 1;
    // ensure runtime fields exist for both sides
    [0,1].forEach(pi=>{
      ['primary','secondary','support'].forEach(slot=>{
        const c = state.players[pi].formation[slot];
        if(c){
          c.currentHp = c.currentHp || c.hp;
          c.currentEnergy = c.currentEnergy || c.energyMax;
          state.players[pi].statuses[c.id] = state.players[pi].statuses[c.id] || {stunned:false,poison:0};
        }
      });
    });
    renderCombatBoards();
    updateCombatUI();
    log('Combat begins!');
  }

  function renderCombatBoards(){
    // highlight active player's board visually
    playerFormationEl.innerHTML=''; opponentFormationEl.innerHTML='';
    const pIdx = state.currentPlayer, oIdx = 1 - pIdx;
    // player's formation (the UI label "Your Formation" is relative to current player)
    ['primary','secondary','support'].forEach(slot=>{
      const slotDiv = document.createElement('div');
      slotDiv.className='slot';
      const card = state.players[pIdx].formation[slot];
      if(card){
        slotDiv.innerHTML = `<div style="font-weight:900">${card.name}</div><div class="meta">HP:${card.currentHp} ATK:${card.atk}</div>
          <div class="energy-bar"><div class="energy-fill" style="width:${Math.round(100*(card.currentEnergy/card.energyMax)||0)}%"></div></div>`;
        slotDiv.dataset.cardId = card.id;
        slotDiv.dataset.slot = slot;
        // markers
        if(state.players[pIdx].statuses[card.id]?.stunned) { const mk=document.createElement('div');mk.className='marker stunned';mk.textContent='STUNNED';slotDiv.appendChild(mk); }
        if(state.players[pIdx].exhausted[card.id]) { const mk=document.createElement('div');mk.className='marker exhausted';mk.textContent='EXH';slotDiv.appendChild(mk); }
      } else { slotDiv.classList.add('empty'); slotDiv.textContent = slot; }
      playerFormationEl.appendChild(slotDiv);
    });
    // opponent formation
    ['primary','secondary','support'].forEach(slot=>{
      const slotDiv = document.createElement('div');
      slotDiv.className='slot';
      const card = state.players[oIdx].formation[slot];
      if(card){
        slotDiv.innerHTML = `<div style="font-weight:900">${card.name}</div><div class="meta">HP:${card.currentHp} ATK:${card.atk}</div>
          <div class="energy-bar"><div class="energy-fill" style="width:${Math.round(100*(card.currentEnergy/card.energyMax)||0)}%"></div></div>`;
        slotDiv.dataset.cardId = card.id;
        slotDiv.dataset.slot = slot;
        // markers for opponent (so you can see)
        if(state.players[oIdx].statuses[card.id]?.stunned) { const mk=document.createElement('div');mk.className='marker stunned';mk.textContent='STUNNED';slotDiv.appendChild(mk); }
        if(state.players[oIdx].exhausted[card.id]) { const mk=document.createElement('div');mk.className='marker exhausted';mk.textContent='EXH';slotDiv.appendChild(mk); }
      } else { slotDiv.classList.add('empty'); slotDiv.textContent = slot; }
      opponentFormationEl.appendChild(slotDiv);
    });

    // click handlers: player's side selects attacker, opponent side selects target
    Array.from(playerFormationEl.children).forEach(el=>{
      el.addEventListener('click', ()=>{
        if(state.phase !== 'combat') return;
        if(el.classList.contains('empty')) return;
        // select attacker from current player
        Array.from(playerFormationEl.children).forEach(c=>c.classList.remove('selected'));
        Array.from(opponentFormationEl.children).forEach(c=>c.classList.remove('selected'));
        el.classList.add('selected');
        state.selectedAttacker = getCardById(state.currentPlayer, el.dataset.cardid || el.dataset.cardId);
        state.selectedTarget = null;
        updateCombatUI();
      });
    });
    Array.from(opponentFormationEl.children).forEach(el=>{
      el.addEventListener('click', ()=>{
        if(state.phase !== 'combat') return;
        if(el.classList.contains('empty')) return;
        Array.from(opponentFormationEl.children).forEach(c=>c.classList.remove('selected'));
        el.classList.add('selected');
        state.selectedTarget = getCardById(1-state.currentPlayer, el.dataset.cardid || el.dataset.cardId);
        updateCombatUI();
      });
    });

    // visual highlight for active player
    if(playerFormationEl) playerFormationEl.classList.toggle('player-highlight', true);
    combatInfoEl.textContent = `Turn ${state.combatTurn} â€” Player ${state.currentPlayer+1}'s turn`;
  }

  function getCardById(playerIndex, cardId){
    if(!cardId) return null;
    const form = state.players[playerIndex].formation;
    for(const s of ['primary','secondary','support']){
      const c = form[s];
      if(c && c.id === cardId) return {card:c,slot:s};
    }
    return null;
  }

  function updateCombatUI(){
    // show turn info
    combatInfoEl.textContent = `Turn ${state.combatTurn} â€” Player ${state.currentPlayer+1}`;
    // Attack enabled?
    let canAttack = false;
    if(state.selectedAttacker && state.selectedTarget){
      const attacker = state.selectedAttacker.card;
      if(attacker.currentEnergy >= 1 && !state.players[state.currentPlayer].exhausted[attacker.id] && !state.players[state.currentPlayer].statuses[attacker.id]?.stunned){
        canAttack = true;
      }
    }
    attackBtn.disabled = !canAttack;
    // Active enabled?
    let canActive = false;
    if(state.selectedAttacker){
      const attacker = state.selectedAttacker.card;
      if(attacker.activeCost > 0 && attacker.currentEnergy >= attacker.activeCost && !state.players[state.currentPlayer].statuses[attacker.id]?.stunned){
        canActive = true;
      }
    }
    activeBtn.disabled = !canActive;
    endTurnBtn.disabled = false;
    // re-render boards to show updated hp/energy
    renderCombatBoards();
  }

  // Attack action
  attackBtn.addEventListener('click', ()=>{
    if(!state.selectedAttacker || !state.selectedTarget) { return; }
    const atk = state.selectedAttacker.card;
    const tgt = state.selectedTarget.card;
    if(atk.currentEnergy < 1) return;
    // spend
    atk.currentEnergy -= 1;
    state.players[state.currentPlayer].exhausted[atk.id] = true;
    // damage
    tgt.currentHp -= atk.atk;
    log(`P${state.currentPlayer+1} ${atk.name} attacked ${tgt.name} for ${atk.atk} dmg.`);
    // passive effects simplistic: if target has return damage
    // check target death
    if(tgt.currentHp <= 0){
      log(`${tgt.name} was defeated.`);
      killCard(1-state.currentPlayer, tgt.id);
      state.selectedTarget = null;
    }
    // small chance to poison from name/desc; status handling
    // update UI
    updateCombatUI();
    // if AI opponent and alive, allow AI to react on its turn
  });

  // Active ability
  activeBtn.addEventListener('click', ()=>{
    if(!state.selectedAttacker) return;
    const atk = state.selectedAttacker.card;
    if(atk.currentEnergy < atk.activeCost) return;
    atk.currentEnergy -= atk.activeCost;
    state.players[state.currentPlayer].exhausted[atk.id] = true;
    // interpret activeDesc heuristically
    const desc = atk.activeDesc.toLowerCase();
    let targetInfo = state.selectedTarget || state.selectedAttacker;
    if(desc.includes('heal')){
      const m = desc.match(/(\\d+)/); const amount = m ? parseInt(m[0],10) : 5;
      targetInfo.card.currentHp = Math.min(targetInfo.card.currentHp + amount, targetInfo.card.hp);
      log(`${atk.name} used active to heal ${targetInfo.card.name} for ${amount}.`);
    } else if(desc.includes('energize') || desc.includes('energise') || desc.includes('+')){
      const m = desc.match(/\\+(\\d+)/); const amount = m ? parseInt(m[1],10) : 2;
      targetInfo.card.currentEnergy = Math.min(targetInfo.card.currentEnergy + amount, targetInfo.card.energyMax);
      log(`${atk.name} energized ${targetInfo.card.name} +${amount}.`);
    } else if(desc.includes('stun')){
      if(state.selectedTarget){
        state.players[1-state.currentPlayer].statuses[state.selectedTarget.card.id].stunned = true;
        log(`${atk.name} stunned ${state.selectedTarget.card.name}.`);
      } else {
        // apply to enemy primary if exists
        const maybe = firstAlive(1-state.currentPlayer);
        if(maybe) { state.players[1-state.currentPlayer].statuses[maybe.id].stunned = true; log(`${atk.name} stunned ${maybe.name}.`); }
      }
    } else if(desc.includes('drain')){
      if(state.selectedTarget){
        const m = desc.match(/(\\d+)/); const amount = m?parseInt(m[0],10):1;
        state.selectedTarget.card.currentEnergy = Math.max(0, state.selectedTarget.card.currentEnergy - amount);
        log(`${atk.name} drained ${amount} energy from ${state.selectedTarget.card.name}.`);
      }
    } else if(desc.includes('seed') || desc.includes('counter') || desc.includes('reflect')){
      log(`${atk.name} used its active ability.`);
    } else {
      log(`${atk.name} used its active ability.`);
    }
    updateCombatUI();
  });

  // End turn: regen energy for that player's cards, clear exhausted flags, reduce temp statuses, switch player, AI move if appropriate
  endTurnBtn.addEventListener('click', ()=>{
    endTurn();
  });

  function endTurn(){
    const p = state.currentPlayer;
    // consumed exhausted flags persist only until end-turn -> cleared now so next time they can act (we use exhausted to mark acted this turn)
    Object.keys(state.players[p].exhausted).forEach(id => state.players[p].exhausted[id] = false);
    // regen 1 energy for each card
    ['primary','secondary','support'].forEach(slot=>{
      const c = state.players[p].formation[slot];
      if(c && c.currentHp > 0){ c.currentEnergy = Math.min(c.energyMax, c.currentEnergy + 1); }
    });
    // apply poison ticks and reduce durations
    ['primary','secondary','support'].forEach(slot=>{
      const c = state.players[p].formation[slot];
      if(c){
        const st = state.players[p].statuses[c.id];
        if(st && st.poison>0){
          c.currentHp -= st.poison;
          log(`${c.name} took ${st.poison} poison.`);
          st.poison = Math.max(0, st.poison-1);
          if(c.currentHp <= 0) { log(`${c.name} died to poison.`); killCard(p, c.id); }
        }
        // stunned flag persists one turn: we clear stunned for this player's side (they skip when stunned)
        if(st && st.stunned){ st.stunned = false; }
      }
    });

    // check defeat
    if(isDefeated(0) || isDefeated(1)){
      if(isDefeated(0) && isDefeated(1)){ phaseEl.textContent = 'Draw!'; log('Both players wiped out.'); disableCombat(); return; }
      if(isDefeated(0)){ phaseEl.textContent = 'Player 2 wins!'; log('Player 2 wins the match.'); disableCombat(); return; }
      if(isDefeated(1)){ phaseEl.textContent = 'Player 1 wins!'; log('Player 1 wins the match.'); disableCombat(); return; }
    }

    // switch player
    state.currentPlayer = 1 - state.currentPlayer;
    state.combatTurn += 1;
    state.selectedAttacker = null; state.selectedTarget = null;
    renderCombatBoards();
    updateCombatUI();

    // if playing vs AI and it's AI's turn, trigger AI turn
    if(!state.twoPlayer && state.currentPlayer === 1){
      setTimeout(()=> aiTakeTurn(), state.aiThinkDelay);
    }
  }

  function disableCombat(){
    attackBtn.disabled = true; activeBtn.disabled = true; endTurnBtn.disabled = true;
  }

  function isDefeated(pi){
    const f = state.players[pi].formation;
    return !( (f.primary && f.primary.currentHp>0) || (f.secondary && f.secondary.currentHp>0) || (f.support && f.support.currentHp>0) );
  }

  function killCard(playerIndex, cardId){
    const f = state.players[playerIndex].formation;
    for(const s of ['primary','secondary','support']){
      if(f[s] && f[s].id === cardId) f[s] = null;
    }
  }

  function firstAlive(playerIndex){
    const f = state.players[playerIndex].formation;
    for(const s of ['primary','secondary','support']){
      const c = f[s];
      if(c && c.currentHp > 0) return c;
    }
    return null;
  }

  // ---- Simple AI: draft, formation, combat ----
  function aiDraftPick(){
    // Simple AI picks highest attack or balanced based on difficulty
    const choices = state.garden;
    if(!choices.length) { generateGardenChoices(); renderGarden(); return; }
    // score cards: Hard prefers high atk low hp if wants kill; Normal balanced; Easy random
    let chosen;
    if(state.difficulty === 'easy') {
      chosen = choices[Math.floor(Math.random()*choices.length)];
    } else {
      // score = atk + (energyMax) + (hp/10) with weights, hard heavier on atk
      let bestScore = -Infinity;
      choices.forEach(c=>{
        const score = c.atk * (state.difficulty==='hard'?2:1.2) + c.energyMax*1.1 + (c.hp/10);
        if(score > bestScore){ bestScore = score; chosen = c; }
      });
    }
    // give copy to AI player (player 1)
    const copy = {...chosen, id:Math.random().toString(36).slice(2)};
    state.players[1].hand.push(copy);
    // remove from garden
    state.garden = state.garden.filter(c=>c.id!==chosen.id);
    renderGarden();
    log('AI picked a card.');
    // return control to human
    state.currentPlayer = 0;
    phaseEl.textContent = `Gardening Phase: Player ${state.currentPlayer+1} pick (${state.players[state.currentPlayer].hand.length}/3)`;
    renderHand();
    // if both have 3 -> formation
    if(state.players[0].hand.length===3 && state.players[1].hand.length===3){
      setTimeout(()=> startFormationSetup(), 300);
    }
  }

  function aiSetFormation(){
    // place AI's 3 cards into primary/secondary/support preferring high HP in primary on hard
    const ai = state.players[1];
    // simple heuristics: primary = tank or highest hp; secondary = highest atk; support = utility
    const hand = ai.hand.slice();
    hand.sort((a,b)=> ( (b.hp - a.hp) )); // default hp sort
    const primary = hand.shift();
    // remaining by atk
    hand.sort((a,b)=> (b.atk - a.atk));
    const secondary = hand.shift();
    const support = hand.shift();
    [primary,secondary,support].forEach((card, idx)=>{
      if(!card) return;
      const runtime = {...card, currentHp:card.hp, currentEnergy:card.energyMax, id: card.id || Math.random().toString(36).slice(2)};
      const slot = idx===0?'primary':(idx===1?'secondary':'support');
      state.players[1].formation[slot] = runtime;
      state.players[1].energy[runtime.id] = runtime.currentEnergy;
      state.players[1].hp[runtime.id] = runtime.currentHp;
      state.players[1].exhausted[runtime.id] = false;
      state.players[1].statuses[runtime.id] = {stunned:false,poison:0};
    });
    // clear AI hand (placed)
    ai.hand = [];
    ai.formationSet = true;
    log('AI placed its formation.');
    // back to player 1 UI
    state.currentPlayer = 0;
    renderHandFormation();
    // both set? start combat
    if(state.players[0].formationSet && state.players[1].formationSet) startCombat();
    else {
      // if player hasn't set (shouldn't happen), remain in formation
      if(!state.players[0].formationSet) {
        phaseEl.textContent = 'Formation Setup: Player 1';
        confirmFormationBtn.disabled = true;
      }
    }
  }

  function aiTakeTurn(){
    // AI will act depending on difficulty
    if(state.phase !== 'combat') return;
    const aiIdx = 1;
    // choose best attacker: prefer alive, not stunned, with energy >=1 (for attack) or >=activeCost
    const candidates = [];
    ['primary','secondary','support'].forEach(s=>{
      const c = state.players[aiIdx].formation[s];
      if(c && c.currentHp>0){
        const st = state.players[aiIdx].statuses[c.id];
        if(st && st.stunned) return; // skip stunned
        candidates.push({card:c,slot:s});
      }
    });
    if(candidates.length===0){ // nothing to do
      endTurn();
      return;
    }
    // decide action: Hard tries to kill low HP enemy, Normal uses abilities sometimes, Easy random
    let action = 'attack'; // attack/active/end
    if(state.difficulty==='easy'){ action = Math.random()<0.15?'active':'attack'; }
    else if(state.difficulty==='normal'){ action = Math.random()<0.33?'active':'attack'; }
    else { // hard: if can kill pick attack, else active strategically
      action = 'attack';
    }

    // pick attacker
    let attackerChoice;
    if(state.difficulty==='easy'){
      attackerChoice = candidates[Math.floor(Math.random()*candidates.length)];
    } else if(state.difficulty==='normal'){
      // prefer attacker with energy >0
      const haveE = candidates.filter(x=>x.card.currentEnergy>0);
      attackerChoice = (haveE.length? haveE[Math.floor(Math.random()*haveE.length)] : candidates[Math.floor(Math.random()*candidates.length)]);
    } else {
      // hard: prefer ones with energy and higher atk
      candidates.sort((a,b)=> b.card.atk - a.card.atk);
      attackerChoice = candidates.find(c=>c.card.currentEnergy>=1) || candidates[0];
    }

    // pick target: choose lowest hp enemy alive (prioritize killable)
    const humanIdx = 0;
    const aliveEnemy = [];
    ['primary','secondary','support'].forEach(s=>{
      const c = state.players[humanIdx].formation[s];
      if(c && c.currentHp>0) aliveEnemy.push({card:c,slot:s});
    });
    if(aliveEnemy.length===0){ endTurn(); return; }
    aliveEnemy.sort((a,b)=> a.card.currentHp - b.card.currentHp);
    let targetChoice = aliveEnemy[0];

    // If hard and active offers kill or strong effect, consider using active
    const attackerCard = attackerChoice.card;
    // prefer using active if it would finish the lowest hp enemy
    if(action==='active' && attackerCard.currentEnergy >= attackerCard.activeCost){
      // try to 'simulate' simple heal/energize rules; we'll just use active if it looks useful
      performAIAttackOrActive(attackerChoice, targetChoice, 'active');
    } else {
      // attack if have energy >=1
      if(attackerCard.currentEnergy >= 1){
        performAIAttackOrActive(attackerChoice, targetChoice, 'attack');
      } else if(attackerCard.currentEnergy >= attackerCard.activeCost && attackerCard.activeCost>0){
        performAIAttackOrActive(attackerChoice, targetChoice, 'active');
      } else {
        // nothing to do -> end turn
        endTurn();
      }
    }
  }

  function performAIAttackOrActive(attackerChoice, targetChoice, mode){
    const aiIdx = 1;
    const atk = attackerChoice.card;
    const tgt = targetChoice.card;
    if(mode==='attack'){
      atk.currentEnergy -= 1;
      state.players[aiIdx].exhausted[atk.id] = true;
      tgt.currentHp -= atk.atk;
      log(`AI ${atk.name} attacked ${tgt.name} for ${atk.atk}.`);
      if(tgt.currentHp <= 0){ log(`${tgt.name} was defeated.`); killCard(0, tgt.id); }
      renderCombatBoards();
      updateCombatUI();
      // small delay then end turn
      setTimeout(()=> endTurn(), 350);
    } else if(mode==='active'){
      if(atk.currentEnergy < atk.activeCost){ setTimeout(()=> endTurn(), 200); return; }
      atk.currentEnergy -= atk.activeCost;
      state.players[aiIdx].exhausted[atk.id] = true;
      const desc = atk.activeDesc.toLowerCase();
      if(desc.includes('heal')){
        const m = desc.match(/(\\d+)/); const amount = m?parseInt(m[0],10):5;
        // heal ally with lowest hp
        let lowest = null;
        ['primary','secondary','support'].forEach(s=>{
          const c = state.players[aiIdx].formation[s];
          if(c && c.currentHp>0 && (!lowest || c.currentHp < lowest.currentHp)) lowest = c;
        });
        if(lowest){ lowest.currentHp = Math.min(lowest.hp, lowest.currentHp + amount); log(`AI ${atk.name} healed ${lowest.name} for ${amount}.`); }
      } else if(desc.includes('energize')){
        // energize self or ally with lowest energy
        let target = atk;
        const m = desc.match(/\\+(\\d+)/); const amount = m?parseInt(m[1],10):2;
        target.currentEnergy = Math.min(target.energyMax, target.currentEnergy + amount);
        log(`AI ${atk.name} energized for +${amount}.`);
      } else if(desc.includes('stun')){
        // stun player's lowest hp
        const target = targetChoice.card;
        state.players[0].statuses[target.id].stunned = true;
        log(`AI ${atk.name} stunned ${target.name}.`);
      } else if(desc.includes('drain')){
        const m = desc.match(/(\\d+)/); const amount = m?parseInt(m[0],10):2;
        targetChoice.card.currentEnergy = Math.max(0, targetChoice.card.currentEnergy - amount);
        log(`AI ${atk.name} drained ${amount} energy from ${targetChoice.card.name}.`);
      } else {
        log(`AI ${atk.name} used active.`);
      }
      renderCombatBoards();
      updateCombatUI();
      setTimeout(()=> endTurn(), 500);
    }
  }

  // ---- Utility: allow human to click on formations when not current player (for two-player) ----
  // Listen to clicks on player/opponent boards for players to pick attackers/targets already implemented in renderCombatBoards

  // ---- Helpers to let human select target (for convenience) ----
  // getCardById already exists

  // ---- Initialization: attach basic UI handlers to ensure starting works ----
  // show difficulty buttons already wired

  // Small helper to show initial instructions
  log('Welcome to Overgrowth! Choose difficulty (or Two Player) to begin, then click Start Draft.');

})();
</script>
</body>
</html>

